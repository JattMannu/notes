<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/dda/ch1/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 1. Reliable, Scalable and Maintainable Applications - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/dda/ch1.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-1-reliable-scalable-and-maintainable-applications">Chapter 1. Reliable, Scalable and Maintainable Applications</a></li>
        
    
        <li class="main "><a href="#thinking-about-data-systems">Thinking About Data Systems</a></li>
        
    
        <li class="main "><a href="#reliability">Reliability</a></li>
        
            <li><a href="#hardware-faults">Hardware faults</a></li>
        
            <li><a href="#software-errors">Software errors</a></li>
        
            <li><a href="#human-errors">Human errors</a></li>
        
            <li><a href="#how-important-is-reliability">How important is reliability?</a></li>
        
    
        <li class="main "><a href="#scalability">Scalability</a></li>
        
            <li><a href="#describing-load">Describing load</a></li>
        
            <li><a href="#describing-performance">Describing performance</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-1-reliable-scalable-and-maintainable-applications"><strong>Chapter 1. Reliable, Scalable and Maintainable Applications</strong><a class="headerlink" href="#chapter-1-reliable-scalable-and-maintainable-applications" title="Permanent link">&para;</a></h3>
<p>Many applications today are <strong>data-intensive</strong>, as opposed to <strong>compute-intensive</strong>. Raw CPU power is rarely a limiting factor for these applications. Bigger problems are usually the amount of data, the complexity of data, and the speed at which it is changing.</p>
<p>A data-intensive application is typically built from standard building blocks which provide common functionality, such as:</p>
<ul>
<li>Store data so that they can be found later (<em>databases</em>)</li>
<li>Remember the result of an expensive operation, to speed up reads (<em>caches</em>)</li>
<li>Allow users to search data by keyword or filter it in various ways (<em>search indexes</em>)</li>
<li>Send a message to another process, to be handled asynchronously (<em>stream processing</em>)</li>
<li>Periodically crunch a large amount of accumulated data (<em>batch processing</em>)</li>
</ul>
<p>When building an application, most engineers wouldn't write a new data storage engine from scratch, because databases are a perfectly good tool for the job. However, there are many database systems with different characteristics, because different applications have different requirements. When building an application, we still need to figure out which tools and which approaches are the most appropriate for the task at hand. Sometimes it can be hard to combine several tools when you need to do something that a single tool cannot do alone.</p>
<p>This chapter starts by exploring the fundamentals of what we are trying to achieve: reliable, scalable and maintainable data systems and then clarify what those things mean, outline some ways of thinking about them, and go over the basics need for later chapters.</p>
<h3 id="thinking-about-data-systems">Thinking About Data Systems<a class="headerlink" href="#thinking-about-data-systems" title="Permanent link">&para;</a></h3>
<p>Typically, databases, queues, caches, etc. are very different categories of tools. Although a database and a message queue have some superficial similarity (both store data for some time), they have very different access patterns, which means different performance characteristics, and thus very different implementations.</p>
<p>Why do we label them under an umbrella term like <em>data systems</em>?</p>
<p>First, many new tools for data storage and processing have emerged in recent years, which are optimized for a variety of different use cases, and they no longer fit into traditional categories. For example, there are data stores that are also used as message queues (Redis), and there are message queues with database-like durability guarantees (Kafka). The boundaries between the categories are becoming blurred.</p>
<p>Second, increasingly many applications now have such demanding or wide-ranging requirements that a single tool can no longer meet all of its data processing and storage needs. Instead, the work is broken down into tasks that can be performed efficiently on a single tool, and those different tools are stitched together using application code.</p>
<p>For example, if you have an application-managed caching layer (using memcached or similar), or a full-text search server separate from your main database (such as Elasticsearch or Solr), it is normally the application code's responsibility to keep those caches and indexes in sync with the main database. The following figure is one possible architecture (which will be detailed in later chapters):</p>
<p><a href="../figure_1-1.png" title="Figure 1-1. One possible architecture for a data system that combines several components."><img alt="Figure 1-1. One possible architecture for a data system that combines several components." src="../figure_1-1_600.png" /></a></p>
<p>When you combine several tools in order to provide a service, the service's interface or API usually hides those implementation details from clients. You have essentially created a new, special-purpose data system from smaller, general-purpose components. Your composite data system may provide certain guarantees, e.g. that the cache will be correctly invalidated or updated on writes, so that outside clients see consistent results.</p>
<p>If you are designing a data system or service, a lot of tricky questions arise:</p>
<ul>
<li>How do you ensure that the data remains correct and complete, even when things go wrong internally?</li>
<li>How do you provide consistently good performance to clients, even when parts of your system are degraded?</li>
<li>How do you scale to handle an increase in load?</li>
<li>What does a good API for the service look like?</li>
</ul>
<p>There are many factors that may influence the design of a data system, including:</p>
<ul>
<li>Skills and experience of the people involved</li>
<li>Legacy system dependencies</li>
<li>Time‐scale for delivery</li>
<li>Organization's tolerance of different kinds of risk</li>
<li>Regulatory constraints</li>
</ul>
<p>This book focuses on three concerns that are important in most software systems:</p>
<ul>
<li><strong>Reliability</strong>. The system should continue to work correctly (performing the correct function at the desired performance) even in the face of adversity (hardware or software faults, and even human error). See <a href="#reliability">Reliability</a>.</li>
<li><strong>Scalability</strong>. As the system grows (in data volume, traffic volume or complexity), there should be reasonable ways of dealing with that growth. See <a href="#scalability">Scalability</a>.</li>
<li><strong>Maintainability</strong>. Over time, many different people will work on the system (engineering and operations, both maintaining current behavior and adapting the system to new use cases), and they should all be able to work on it productively. See <a href="#maintainability">Maintainability</a>.</li>
</ul>
<h3 id="reliability">Reliability<a class="headerlink" href="#reliability" title="Permanent link">&para;</a></h3>
<p>Typical expectations for software include:</p>
<ul>
<li>The application performs the function that the user expected.</li>
<li>It can tolerate the user making mistakes, or using the software in unexpected ways.</li>
<li>Its performance is good enough for the required use case, under expected load and data volume.</li>
<li>The system prevents any unauthorized access and abuse.</li>
</ul>
<p>If all those things together mean "working correctly", then <em>reliability</em> roughly means "continuing to work correctly, even when things go wrong".</p>
<p>The things that can go wrong are called <em>faults</em>, and systems that anticipate faults and can cope with them are called <a href="https://en.wikipedia.org/wiki/Fault_tolerance"><em>fault-tolerant</em></a> or <em>resilient</em>. The term is slightly misleading: it suggests that we could make a system tolerant of every possible kind of fault, which in reality is not feasible. It only makes sense to talk about tolerating certain <em>types of fault</em>.</p>
<p>Note that a <em>fault</em> is not the same as a <em>failure</em>.</p>
<ul>
<li>A fault is usually defined as one component of the system deviating from its spec.</li>
<li>A failure is when the system as a whole stops providing the required service to the user.</li>
</ul>
<p>It is impossible to reduce the probability of a fault to zero; therefore it is usually best to design fault tolerance mechanisms that prevent faults from causing failures. This book covers several techniques for building reliable systems from unreliable parts.</p>
<p>Counter-intuitively, in such fault-tolerant systems, it can make sense to increase the rate of faults by triggering them deliberately (for example, by randomly killing individual processes without warning). Many critical bugs are actually due to poor error handling; by deliberately inducing faults, you ensure that the fault-tolerance machinery is continually exercised and tested, which can increase your confidence that faults will be handled correctly when they occur naturally. The Netflix <a href="https://github.com/Netflix/chaosmonkey">chaos monkey</a> is an example of this approach.</p>
<p>Although we generally prefer tolerating faults over preventing faults, there are cases where prevention is better than cure (e.g. because no cure exists). This is the case with security matters, for example: if an attacker has compromised a system and gained access to sensitive data, that event cannot be undone. However, this book mostly deals with the kinds of fault that can be cured, as described in the following sections.</p>
<h4 id="hardware-faults">Hardware faults<a class="headerlink" href="#hardware-faults" title="Permanent link">&para;</a></h4>
<p>Hardware faults are a common cause of system failure. For example:</p>
<ul>
<li>Hard disks crash</li>
<li>RAM becomes faulty</li>
<li>The power grid has a blackout</li>
<li>Someone unplugs the wrong network cable</li>
</ul>
<p>These things happen <em>all the time</em> when you have a lot of machines.</p>
<p>Hard disks are reported as having a <a href="https://en.wikipedia.org/wiki/Mean_time_between_failures">mean time to failure</a> (MTTF) of about 10 to 50 years. Thus, on a storage cluster with 10,000 disks, we should expect on average one disk to die per day.</p>
<p>Adding redundancy to the individual hardware components can reduce the failure rate of the system. For example:</p>
<ul>
<li>Disks may be set up in a RAID configuration.</li>
<li>Servers may have dual power supplies and hot-swappable CPUs.</li>
<li>Data centers may have batteries and diesel generators for backup power.</li>
</ul>
<p>When one component dies, the redundant component can take its place while the broken component is replaced. This approach cannot completely prevent hardware problems from causing failures, but it is well understood, and can often keep a machine running uninterrupted for years.</p>
<p>Redundancy of hardware components was sufficient for most applications, since it makes total failure of a single machine fairly rare. As long as you can restore a backup onto a new machine fairly quickly, the downtime in case of failure is not catastrophic in most applications. Thus, multi-machine redundancy was only required by a small number of applications for which high availability was absolutely essential.</p>
<p>However, as data volumes and computing demands increase, more applications are using larger numbers of machines, which proportionally increases the rate of hardware faults. Moreover, in some "cloud" platforms such as Amazon Web Services it is fairly common for virtual machine instances to become unavailable without warning, as the platform is designed to prioritize flexibility and <a href="https://en.wikipedia.org/wiki/Elasticity_(cloud_computing)">elasticity</a> over single-machine reliability.</p>
<p>Hence there is a move towards systems that can tolerate the loss of entire machines, by using <a href="https://en.wikipedia.org/wiki/Software_fault_tolerance">software fault-tolerance</a> techniques in preference to hardware redundancy. Such systems also have operational advantages: a single-server system requires planned downtime if you need to reboot the machine (to apply operating system security patches, for example), whereas a system that can tolerate machine failure can be patched one node at a time, without downtime of the entire system.</p>
<h4 id="software-errors">Software errors<a class="headerlink" href="#software-errors" title="Permanent link">&para;</a></h4>
<p>Hardware faults are usually considered as being random and independent from each other: one machine's disk failing does not imply that another machine's disk is going to fail. There may be weak correlations (for example due to a common cause, such as the temperature in the server rack), but otherwise it is unlikely that a large number of hardware components will fail at the same time.</p>
<p>Another class of fault is a systematic error within the system, which are harder to anticipate. Because they are correlated across nodes, they tend to cause many more system failures than uncorrelated hardware faults. Examples include:</p>
<ul>
<li>A software bug that causes every instance of an application server to crash when given a particular bad input. For example, consider the <a href="https://en.wikipedia.org/wiki/Leap_second">leap second</a> on <a href="https://en.wikipedia.org/wiki/Leap_second#Examples_of_problems_associated_with_the_leap_second">June 30, 2012</a> that caused many applications to hang simultaneously, due to a bug in the Linux kernel.</li>
<li>A runaway process uses up some shared resource: CPU time, memory, disk space or network bandwidth.</li>
<li>A service that the system depends on slows down, becomes unresponsive or starts returning corrupted responses.</li>
<li><a href="https://en.wikipedia.org/wiki/Cascading_failure">Cascading failures</a>, where a small fault in one component triggers a fault in another component, which in turn triggers further faults.</li>
</ul>
<p>The bugs that cause these kinds of software fault often lie dormant for a long time until they are triggered by an unusual set of circumstances. In those circumstances, it is revealed that the software is making some kind of assumption about its environment, and while that assumption is usually true, it eventually stops being true for some reason.</p>
<p>There is no quick solution to systematic faults in software, but many small things can help:</p>
<ul>
<li>Carefully thinking about assumptions and interactions in the system</li>
<li>Thorough testing</li>
<li>Process isolation</li>
<li>Allowing processes to crash and restart</li>
<li>Measuring, monitoring and analyzing system behavior in production</li>
</ul>
<p>If a system is expected to provide some guarantee (for example, in a message queue the number of incoming messages equals the number of outgoing messages), it can constantly check itself while it is running, and raise an alert if a discrepancy is found.</p>
<h4 id="human-errors">Human errors<a class="headerlink" href="#human-errors" title="Permanent link">&para;</a></h4>
<p>Humans design and build software systems, and the operators who keep the system running are also human. Even when they have the best intentions, humans are known to be unreliable. A study of large Internet services found that configuration errors by operators were the leading cause of outages, whereas hardware faults (servers or network) cause only 10–25% of outages.</p>
<p>The best systems combine several approaches in spite of unreliable humans:</p>
<ul>
<li>Design systems that minimizes opportunities for error. For example, well-designed abstractions, APIs and admin interfaces make it easy to do "the right thing", and discourage "the wrong thing". However, if the interfaces are too restrictive, people will work around them, negating their benefit, so this is a tricky balance to get right.</li>
<li>Decouple the places where people make the most mistakes from the places where they can cause failures. In particular, provide fully-featured non-production sandbox environments where people can explore and experiment safely, using real data, without affecting real users.</li>
<li>Test thoroughly at all levels, from unit tests to whole-system integration tests and manual tests. Automated testing is widely used and valuable for covering corner cases that rarely arise in normal operation.</li>
<li>Allow quick and easy recovery from human errors, to minimize the impact in the case of a failure. For example:<ul>
<li>Make it fast to roll back configuration changes.</li>
<li>Roll out new code gradually (so that any unexpected bugs affect only a small subset of users).</li>
<li>Provide tools to recompute data (in case it turns out that the old computation was incorrect).</li>
</ul>
</li>
<li>Set up detailed and clear monitoring, such as performance metrics and error rates. In other engineering disciplines this is referred to as <a href="https://en.wikipedia.org/wiki/Telemetry"><em>telemetry</em></a> (for example, once a rocket has left the ground, telemetry is essential for tracking what is happening and for understanding failures). Monitoring can show us early warning signals, and allow us to check whether any assumptions or constraints are being violated. When a problem occurs, metrics can be invaluable in diagnosing the issue.</li>
<li>Good management practices and training.</li>
</ul>
<h4 id="how-important-is-reliability">How important is reliability?<a class="headerlink" href="#how-important-is-reliability" title="Permanent link">&para;</a></h4>
<p>Bugs in business applications cause lost productivity (and legal risks if figures are reported incor‐ rectly), and outages of e-commerce sites can have huge costs in terms of lost revenue and reputation. Even in "non-critical" applications we have a responsibility to our users.</p>
<p>There are situations in which we may choose to sacrifice reliability in order to reduce development cost (e.g. when developing a prototype product for an unproven market) or operational cost (e.g. for a service with a very narrow profit margin), but we should be very conscious of when we are cutting corners.</p>
<h3 id="scalability">Scalability<a class="headerlink" href="#scalability" title="Permanent link">&para;</a></h3>
<p>That a system is working reliably today doesn't mean it will necessarily work
reliably in future. One common reason for degradation is increased load:</p>
<ul>
<li>Perhaps it has grown from 10,000 concurrent users to 100,000 concurrent users.</li>
<li>Perhaps it is processing much larger volumes of data than it did before.</li>
</ul>
<p>Scalability is the term to describe a system's ability to cope with increased load. It is not a one-dimensional label that we can attach to a system: it is meaningless to say "X is scalable" or "Y doesn't scale". Rather, discussing scalability means to discuss the question: if the system grows in a particular way, what are our options for coping with the growth? How can we add computing resources to handle the additional load?</p>
<h4 id="describing-load">Describing load<a class="headerlink" href="#describing-load" title="Permanent link">&para;</a></h4>
<p>Load can be described with a few numbers which we call <em>load parameters</em>. The best choice of parameters depends on the architecture of your system. For example, it can be:</p>
<ul>
<li>Requests per second to a webserver</li>
<li>Ratio of reads to writes in a database</li>
<li>The number of simultaneously active users in a chat room</li>
<li>The hit rate on a cache</li>
</ul>
<p>Perhaps the average case is what matters for you, or perhaps your bottleneck is dominated by a small number of extreme cases.</p>
<p>Consider Twitter as an example, using data published in November 2012. Two of Twitter's main operations are:</p>
<ul>
<li><em>Post tweet</em>. A user can publish a new message to their followers (4.6 k requests/sec on average, over 12 k requests/sec at peak).</li>
<li><em>Home timeline</em>. A user can view tweets recently published by the people they follow (300 k requests/sec).</li>
</ul>
<p>Simply handling 12,000 writes per second (the peak rate for posting tweets) would be fairly easy. However, Twitter's scaling challenge is not primarily due to tweet volume, but due to <a href="https://en.wikipedia.org/wiki/Fan-out_(software)">fan-out</a> (In transaction processing systems, we use it to describe the number of requests to other services that we need to make in order to serve one incoming request): each user follows many people, and each user is followed by many people.</p>
<p>There are broadly two approaches to implementing these two operations:</p>
<p>Approach 1: posting a tweet inserts the new tweet into a global collection of tweets. When a user requests home timeline:</p>
<ol>
<li>Look up all the people they follow.</li>
<li>Find all recent tweets for each of those users</li>
<li>Merge them (sorted by time).</li>
</ol>
<p>In a relational database like the one in the following figure:</p>
<p><a href="../figure_1-2.png" title="Figure 1-2. Simple relational schema for implementing a Twitter home timeline."><img alt="Figure 1-2. Simple relational schema for implementing a Twitter home timeline." src="../figure_1-2_600.png" /></a></p>
<p>The SQL query of it would be like:</p>
<div class="codehilite"><pre><span class="k">SELECT</span> <span class="n">tweets</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">users</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">tweets</span>
 <span class="k">JOIN</span> <span class="n">users</span> <span class="k">ON</span> <span class="n">tweets</span><span class="p">.</span><span class="n">sender_id</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span>
 <span class="k">JOIN</span> <span class="n">follows</span> <span class="k">ON</span> <span class="n">follows</span><span class="p">.</span><span class="n">followee_id</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span>
 <span class="k">WHERE</span> <span class="n">follows</span><span class="p">.</span><span class="n">follower_id</span> <span class="o">=</span> <span class="k">current_user</span>
</pre></div>


<p>Approach 2: maintain a cache for each user's home timeline (see figure below). When a user posts a tweet, look up all the people who follow that user, and insert the new tweet into each of their home timeline caches. The request to read the home timeline is cheap, because its result has been computed ahead of time.</p>
<p><a href="../figure_1-3.png" title="Figure 1-3. Twitter's data pipeline for delivering tweets to followers, with load parameters as of November 2012"><img alt="Figure 1-3. Twitter's data pipeline for delivering tweets to followers, with load parameters as of November 2012" src="../figure_1-3_600.png" /></a></p>
<p>The first version of Twitter used approach 1, but the systems struggled to keep up with the load of home timeline queries, so the company switched to approach 2. This works better because the average rate of published tweets is almost two orders of magnitude lower than the rate of home timeline reads, so it's preferable to do more work at write time and less at read time.</p>
<p>However, the downside of approach 2 is that posting a tweet now requires a lot of extra work. A tweet is delivered to about 75 followers on average, so 4.6 k tweets per second become 345 k writes per second to the home timeline caches. However, the number of followers per user varies wildly, and some users have over 30 million followers. This means that a single tweet may result in over 30 million writes to home timelines. It is a significant challenge to deliver tweets to followers in a timely manner.</p>
<p>In Twitter, the distribution of followers per user (maybe weighted by how often those users tweet) is a key load parameter for discussing scalability, since it determines the fan-out load. Now that approach 2 is robustly implemented, Twitter is moving to a hybrid of both approaches. Most users' tweets continue to be fanned out to home timelines at the time when they are posted, but a small number of users with a very large number of followers are excepted from this fan-out. Instead, when the home timeline is read, the tweets from celebrities followed by the user are fetched separately and merged with the home timeline when the timeline is read, like in approach 1. This hybrid approach is able to deliver consistently good performance.</p>
<h4 id="describing-performance">Describing performance<a class="headerlink" href="#describing-performance" title="Permanent link">&para;</a></h4>
<p>Once you have described the load on our system, you can investigate what happens when the load increases in two ways:</p>
<ul>
<li>When you increase a load parameter, and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is performance of your system affected?</li>
<li>When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged?</li>
</ul>
<p>Both questions require performance numbers.</p>
<p>In a batch-processing system such as Hadoop, we usually care about <a href="https://en.wikipedia.org/wiki/Throughput"><em>throughput</em></a>: the number of records we can process per second, or the total time it takes to run a job on a dataset of a certain size.</p>
<ul>
<li>In an ideal world, the running time of a batch job is the size of the dataset divided by throughput.</li>
<li>In practice, the running time is often longer, due to skew (data not being spread evenly across worker processes) or waiting for the slowest task to complete.</li>
</ul>
<p>In online systems, the <a href="https://en.wikipedia.org/wiki/Response_time_(technology)"><em>response time</em></a> of a service is usually more important. It is time between a client sending a request and receiving a response.</p>
<h5 id="latency-vs-response-time"><strong>Latency vs. Response Time</strong> *<a class="headerlink" href="#latency-vs-response-time" title="Permanent link">&para;</a></h5>
<p><a href="https://en.wikipedia.org/wiki/Latency_(engineering)">Latency</a> and response time are often used synonymously, but they are not the same.</p>
<ul>
<li>The response time is what the client sees: besides the actual time to process the request (the service time), it includes network delays and queueing delays.</li>
<li>Latency is the duration that a request is waiting to be handled, during which it is latent, awaiting service.</li>
</ul>
<p>Even if you only make the same request over and over again, you will get a slightly different response time on every try. In practice, in a system handling a variety of requests, the response time can vary a lot. Therefore, we need to think of response time not as a single number, but as a distribution of values that you can measure.</p>
<p>In the following figure, each gray bar represents a request to a service, and its height shows how long that request took.</p>
<p><a href="../figure_1-4.png" title="Figure 1-4. Illustrating mean and percentiles: response times for a sample of 100 requests to a service"><img alt="Figure 1-4. Illustrating mean and percentiles: response times for a sample of 100 requests to a service" src="../figure_1-4_600.png" /></a></p>
<p>Most requests are reasonably fast, but there are occasional <a href="https://en.wikipedia.org/wiki/Outlier"><em>outliers</em></a> that take much longer. The slow requests may be intrinsically more expensive, e.g. because they process more data. But even in a scenario where all requests should take the same time, you get variation, where random additional latency could be introduced by:</p>
<ul>
<li>A context switch to a background process</li>
<li>The loss of a network packet and TCP retransmission</li>
<li>A garbage collection pause</li>
<li>A page fault forcing a read from disk</li>
<li>Mechanical vibrations in the server rack</li>
<li>Many other things</li>
</ul>
<h5 id="percentiles-p50-p95-p99-and-p999"><strong>Percentiles: p50, p95, p99 and p99.9</strong> *<a class="headerlink" href="#percentiles-p50-p95-p99-and-p999" title="Permanent link">&para;</a></h5>
<p>It's common to use the <em>average</em> response. Strictly speaking, the term <em>average</em> doesn't refer to any particular formula, but in practice it is usually understood as the <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a>: sum the <em>n</em> values and divide by <em>n</em>.) However, the mean is not a very good metric to know the "typical" response time, because it doesn't tell how many users actually experienced that delay.</p>
<p>Usually it is better to use <a href="https://en.wikipedia.org/wiki/Percentile"><em>percentiles</em></a>. If you take your list of response times and sort it, from fastest to slowest, then the median is the half-way point: for example, if your median response time is 200 ms, that means half your requests return in less than 200 ms, and half your requests take longer than that.</p>
<p><u>This makes the median a good metric if you want to know how long users typically have to wait</u>: half of user requests are served in less than the median response time, and the other half take longer than the median. The median is also known as <strong>50th percentile</strong>, and sometimes abbreviated as <strong>p50</strong>. Note that the median is the half-way point for a single request; if the user makes several requests (over the course of a session, or because several resources are included in a single page), the probability that at least one of them is slower than the median is much greater than 50%.</p>
<p>In order to figure out how bad your outliers are, you can look at higher percentiles: the <strong>95th</strong>, <strong>99th</strong> and <strong>99.9th percentile</strong> are common (abbreviated <strong>p95</strong>, <strong>p99</strong> and <strong>p99.9</strong>). They are the response time thresholds at which 95%, 99% or 99.9% of requests are faster than that particular threshold. For example, if the 95th percentile response time is 1.5 seconds, that means 95 out of 100 requests take less than 1.5 seconds, and 5 out of 100 requests take 1.5 seconds or more.</p>
<p><u>High percentiles are important because they directly affect user experience of the service.</u> For example, Amazon describes response time requirements for internal services in terms of the 99.9th percentile, even though it only affects 1 in 1,000 requests. This is because the customers with the slowest requests are often those who have made many purchases, i.e. the most valuable customers. It's important to keep those customers happy by ensuring the website is fast for them: Amazon has also observed that a 100 ms increase in response time reduces sales by 1% and others report that a 1-second slowdown reduces a customer satisfaction metric by 16%.</p>
<p>On the other hand, optimizing the 99.99th percentile (the slowest 1 in 10,000 requests) was deemed too expensive and not yield enough benefit for Amazon's purposes. Reducing response times at very high percentiles is difficult because they are easily affected by random events outside of your control, and the benefits are diminishing.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>