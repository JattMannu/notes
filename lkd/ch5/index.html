<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/lkd/ch5/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 5. System Calls - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                    
                      
                        <li class="active">
                            <a href="./">Chapter 5. System Calls</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol </a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD) </a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LSP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../lsp/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lsp/ch9/">Chapter 9. Memory Management</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TLPI <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../tlpi/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tlpi/ch6/">Chapter 6. Processes</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tlpi/ch7/">Chapter 7. Memory Allocation</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
            <!-- Hide pages from the navigation -->
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                    
                      
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../ruby/">Ruby</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../python/">Python</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../asm/">x86 assembly</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/lkd/ch5.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-5-system-calls">Chapter 5. System Calls</a></li>
        
    
        <li class="main "><a href="#communicating-with-the-kernel">Communicating with the Kernel</a></li>
        
    
        <li class="main "><a href="#apis-posix-and-the-c-library">APIs, POSIX, and the C Library</a></li>
        
            <li><a href="#apis">APIs *</a></li>
        
            <li><a href="#posix">POSIX *</a></li>
        
            <li><a href="#the-c-library">The C Library *</a></li>
        
    
        <li class="main "><a href="#syscalls">Syscalls</a></li>
        
            <li><a href="#system-call-numbers">System Call Numbers</a></li>
        
            <li><a href="#system-call-performance">System Call Performance</a></li>
        
    
        <li class="main "><a href="#system-call-handler">System Call Handler</a></li>
        
            <li><a href="#denoting-the-correct-system-call">Denoting the Correct System Call</a></li>
        
            <li><a href="#parameter-passing">Parameter Passing</a></li>
        
    
        <li class="main "><a href="#system-call-implementation">System Call Implementation</a></li>
        
            <li><a href="#implementing-system-calls">Implementing System Calls</a></li>
        
            <li><a href="#verifying-the-parameters">Verifying the Parameters</a></li>
        
    
        <li class="main "><a href="#system-call-context">System Call Context</a></li>
        
            <li><a href="#final-steps-in-binding-a-system-call">Final Steps in Binding a System Call</a></li>
        
            <li><a href="#accessing-the-system-call-from-user-space">Accessing the System Call from User-Space</a></li>
        
            <li><a href="#why-not-to-implement-a-system-call">Why Not to Implement a System Call</a></li>
        
    
        <li class="main "><a href="#conclusion">Conclusion</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-5-system-calls"><strong>Chapter 5. System Calls</strong></h3>
<blockquote>
<p>Look at <code>ioctl()</code> as an example of what not to do (when implementing a system call).
<small>Robert Love</small></p>
</blockquote>
<p>In any modern operating system, the kernel provides a set of interfaces by which processes running in user-space can interact with the system. These interfaces give applications: [p69]</p>
<ul>
<li>controlled access to hardware,</li>
<li>a mechanism with which to create new processes and communicate with existing ones,</li>
<li>and the capability to request other operating system resources.</li>
</ul>
<p>The existence of these interfaces, and the fact that applications are not free to directly do whatever they want, is key to providing a stable system</p>
<h3 id="communicating-with-the-kernel">Communicating with the Kernel</h3>
<p>System calls provide a layer between the hardware and user-space processes, which serves three primary purposes:</p>
<ol>
<li><strong>Providing an abstracted hardware interface for userspace.</strong><ul>
<li>For example, when reading or writing from a file, applications are not concerned with the type of disk, media, or even the type of filesystem on which the file resides.</li>
</ul>
</li>
<li><strong>Ensuring system security and stability.</strong> The kernel acts as a middleman between system resources and user-space, so it can arbitrate access based on permissions, users, and other criteria.<ul>
<li>For example, this arbitration prevents applications from incorrectly using hardware, stealing other processes’ resources, or otherwise doing harm to the system.</li>
</ul>
</li>
<li><strong>A single common layer between user-space and the rest of the system allows for the virtualized system provided to processes.</strong>  It would be impossible to implement multitasking and virtual memory if applications were free to access access system resources without the kernel’s knowledge. [p69]</li>
</ol>
<p>In Linux, system calls are the only means user-space has of interfacing with the kernel and the only legal entry point into the kernel other than exceptions and traps. Other interfaces, such as device files or <code>/proc</code>, are ultimately accessed via system calls. Interestingly, Linux implements far fewer system calls than most systems.</p>
<h3 id="apis-posix-and-the-c-library">APIs, POSIX, and the C Library</h3>
<h4 id="apis">APIs *</h4>
<p>Applications are typically programmed against an Application Programming Interface (API) implemented in user-space, not directly to system calls, because no direct correlation is needed between the interfaces used by applications and the actual interface provided by the kernel.</p>
<p>An API defines a set of programming interfaces used by applications. Those interfaces can be:</p>
<ul>
<li>implemented as a system call,</li>
<li>implemented through multiple system calls, or</li>
<li>implemented without the use of system calls at all.</li>
</ul>
<p>The same API can exist on multiple systems and provide the same interface to applications while the implementation of the API itself can differ greatly from system to system.</p>
<p>The figure below shows relationship between a POSIX API, the C library, and system calls.</p>
<p><a href="../figure_5.1.png" title="Figure 5.1 The relationship between applications, the C library, and the kernel with a call to printf()."><img alt="Figure 5.1 The relationship between applications, the C library, and the kernel with a call to printf()." src="../figure_5.1_600.png" /></a></p>
<h4 id="posix">POSIX *</h4>
<p>The most common APIs in the Unix world is based on POSIX. Technically, POSIX is composed of a series of standards from the <a href="https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers">IEEE</a> that aim to provide a portable operating system standard roughly based on Unix. Linux strives to be POSIX- and SUSv3-compliant where applicable.</p>
<p>On most Unix systems, the POSIX-defined API calls have a strong correlation to the system calls. Some systems that are rather un-Unix, such as Microsoft Windows, offer POSIX-compatible libraries. [p70]</p>
<h4 id="the-c-library">The C Library *</h4>
<p>The system call interface in Linux, as with most Unix systems, is provided in part by the C library.</p>
<p>The C library implements the main API on Unix systems, including:</p>
<ul>
<li>The standard C library</li>
<li>The system call interface</li>
</ul>
<p>The C library is used by all C programs and, because of C’s nature, is easily wrapped by other programming languages for use in their programs. The C library additionally provides the majority of the POSIX API.</p>
<p>From the application programmer’s point of view, system calls are irrelevant; all the programmer is concerned with is the API. Conversely, the kernel is concerned only with the system calls; what library calls and applications make use of the system calls is not of the kernel’s concern. Nonetheless, it is important for the kernel to keep track of the potential uses of a system call and keep the system call as general and flexible as possible.</p>
<p>A meme related to interfaces in Unix is "Provide mechanism, not policy". In other words, Unix system calls exist to provide a specific function in an abstract sense. The manner in which the function is used is not any of the kernel’s business.</p>
<h3 id="syscalls">Syscalls</h3>
<p><strong>System calls</strong> (often called <strong>syscalls</strong> in Linux) are typically accessed via function calls defined in the C library.</p>
<ul>
<li>The functions can define zero, one, or more arguments (inputs) and might result in one or more side effects.<ul>
<li>Although nearly all system calls have a side effect (that is, they result in some change of the system’s state), a few syscalls, such as <code>getpid()</code>, merely return some data from the kernel.</li>
</ul>
</li>
<li>System calls also provide a return value of type <code>long</code> (for compatibility with 64-bit architectures) that signifies success or error.<ul>
<li>Usually, although not always, a negative return value denotes an error.</li>
<li>A return value of zero is usually (not always) a sign of success.</li>
<li>The C library (when a system call returns an error) writes a special error code into the global <code>errno</code> variable, which can be translated into human-readable errors via library functions such as <code>perror()</code>.</li>
</ul>
</li>
<li>System calls have a defined behavior. (see the following example)</li>
</ul>
<p>The system call <code>getpid()</code> is defined to return an integer that is the current process’s PID. The implementation of this syscall in the kernel is simple:</p>
<div class="codehilite"><pre><span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">getpid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span> <span class="c1">// returns current-&gt;tgid</span>
<span class="p">}</span>
</pre></div>


<p>The definition says nothing of the implementation. The kernel must provide the intended behavior of the system call but is free to do so with whatever implementation it wants as long as the result is correct. [p72]</p>
<p><code>SYSCALL_DEFINE0</code> is simply a macro that defines a system call with no parameters (hence the 0). The expanded code looks like this:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/syscalls.h##L285">include/linux/syscalls.h</a></small></p>
<div class="codehilite"><pre><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_getpid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>


<ul>
<li>The <code>asmlinkage</code> modifier on the function definition is a directive to tell the compiler to look only on the stack for this function’s arguments. This is a required modifier for all system calls.</li>
<li>The function returns a <code>long</code>. For compatibility between 32- and 64-bit systems, system calls defined to return an <code>int</code> in user-space return a <code>long</code> in the kernel.</li>
<li>The naming convention taken with all system calls in Linux is: System call <code>bar()</code> is implemented in the kernel as function <code>sys_bar()</code>.</li>
</ul>
<h4 id="system-call-numbers">System Call Numbers</h4>
<p>In Linux, each system call is assigned a unique <strong>syscall number</strong> that is used to reference a specific system call. When a user-space process executes a system call, the syscall number identifies which syscall was executed; the process does not refer to the syscall by name.</p>
<ul>
<li>When assigned, the syscall number cannot change; otherwise, compiled applications will break.</li>
<li>If a system call is removed, its system call number cannot be recycled, or previously compiled code would aim to invoke one system call but would in reality invoke another.</li>
<li>Linux provides a "not implemented" system call, <code>sys_ni_syscall()</code>, which does nothing except return <code>ENOSYS</code>, the error corresponding to an invalid system call. This function is used to "plug the hole" in the rare event that a syscall is removed or otherwise made unavailable.</li>
</ul>
<p>The kernel keeps a list of all registered system calls in the system call table, stored in <code>sys_call_table</code>, on x86-64 it is defined in <a href="https://github.com/shichao-an/linux/blob/v2.6.34/arch/x86/kernel/syscall_64.c">arch/x86/kernel/syscall_64.c</a>.</p>
<p>The system call numbers are defined in the file <a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/asm-generic/unistd.h">include/asm-generic/unistd.h</a>.</p>
<h4 id="system-call-performance">System Call Performance</h4>
<p>System calls in Linux are faster than in many other operating systems, because of:</p>
<ul>
<li>Linux’s fast context switch times: entering and exiting the kernel is a streamlined and simple affair</li>
<li>Simplicity of the system call handler and the individual system calls themselves</li>
</ul>
<h3 id="system-call-handler">System Call Handler</h3>
<p>It is not possible for user-space applications to execute kernel code directly. They cannot simply make a function call to a method existing in kernel-space because the kernel exists in a protected memory space. Otherwise, system security and stability would be nonexistent.</p>
<p>User-space applications signal the kernel that they want to execute a system call and have the system switch to kernel mode, where the system call can be executed in kernel-space by the kernel on behalf of the application. This mechanism is software interrupt: incur an exception, and the system will switch to kernel mode and execute the <strong>exception handler</strong>. The exception handler in this case is actually the <strong>system call handler</strong>.</p>
<p>The defined software interrupt on x86 is interrupt number 128, which is incurred via the <code>int $0x80</code> instruction. It triggers a switch to kernel mode and the execution of exception vector 128, which is the system call handler. The system call handler is the aptly named function <code>system_call()</code>. It is architecture-dependent; on x86-64 it is implemented in assembly in <code>entry_64.S</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/arch/x86/kernel/entry_64.S">arch/x86/kernel/entry_64.S</a>).</p>
<p>Recently, x86 processors added a feature known as <em>sysenter</em>, which provides a faster, more specialized way of trapping into a kernel to execute a system call than using the <code>int</code> interrupt instruction. Support for this feature was quickly added to the kernel. Regardless of how the system call handler is invoked, however, the important notion is that somehow user-space causes an exception or trap to enter the kernel.</p>
<h4 id="denoting-the-correct-system-call">Denoting the Correct System Call</h4>
<p>For more details of Linux system call from the assembly perspective, see <a href="../../asm/#interfacing-with-linux-system-calls">Interfacing with Linux</a>.</p>
<p>Simply entering kernel-space alone is not sufficient: the system call number must be passed into the kernel.</p>
<p>On x86, the syscall number is passed to the kernel via the <code>eax</code> register:</p>
<ul>
<li>Before causing the trap into the kernel, user-space sticks in <code>eax</code> the number corresponding to the desired system call.</li>
<li>The system call handler then reads the value from <code>eax</code></li>
</ul>
<p>The <code>system_call()</code> function checks the validity of the given system call number by comparing it to <code>NR_syscalls</code>. If it is larger than or equal to <code>NR_syscalls</code>, the function returns -<code>ENOSYS</code>. Otherwise, the specified system call is invoked:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/arch/x86/kernel/entry_64.S#L487">arch/x86/kernel/entry_64.S#L487</a></small></p>
<div class="codehilite"><pre><span class="nf">call</span> <span class="p">*</span><span class="no">sys_call_table</span><span class="p">(,</span><span class="nv">%rax</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</pre></div>


<p>Because each element in the system call table is 64 bits (8 bytes), the kernel multiplies the given system call number by eight to arrive at its location in the system call table. On x86-32, the code is similar, with the 8 replaced by 4.</p>
<p><a href="../figure_5.2.png" title="Figure 5.2 Invoking the system call handler and executing a system call."><img alt="Figure 5.2 Invoking the system call handler and executing a system call." src="../figure_5.2.png" /></a></p>
<h4 id="parameter-passing">Parameter Passing</h4>
<p>In addition to the system call number, most syscalls require that one or more parameters be passed to them. User-space must relay the parameters to the kernel during the trap. The easiest way to do this is similar to how the syscall number is passed: The parameters are stored in registers. On x86-32, the registers <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>esi</code>, and <code>edi</code> contain, in order, the first five arguments. In the unlikely case of six or more arguments, a single register is used to hold a pointer to user-space where all the parameters are stored.</p>
<p>The return value is sent to user-space also via register. On x86, it is written into the <code>eax</code> register.</p>
<h3 id="system-call-implementation">System Call Implementation</h3>
<p>The actual implementation of a system call in Linux does not need to be concerned with the behavior of the system call handler. Thus, adding a new system call to Linux is relatively easy. The hard work lies in designing and implementing the system call; registering it with the kernel is simple.</p>
<h4 id="implementing-system-calls">Implementing System Calls</h4>
<p>The first step in implementing a system call is defining its purpose and the syscall should have exactly one purpose. Multiplexing syscalls (a single system call that does wildly different things depending on a flag argument) is discouraged in Linux. <code>ioctl()</code> is an example of what <em>not</em> to do.</p>
<p>Think of the new system call’s arguments, return value, and error codes. The system call should have a clean and simple interface with the smallest number of arguments possible.The semantics and behavior of a system call are important; they must not change, because existing applications will come to rely on them. Many system calls provide a flag argument to address forward compatibility. The flag is not used to multiplex different behavior across a single system call (which is not acceptable), but to enable new functionality and options without breaking backward compatibility or needing to add a new system call. [p75]</p>
<p>Design the system call to be as general as possible with an eye toward the future. <u>The <em>purpose</em> of the system call will remain constant but its <em>uses</em> may change.</u> Remember the Unix motto: "Provide mechanism, not policy." [p75]</p>
<p>When you write a system call, you need to realize the need for portability and robustness, not just today but in the future.The basic Unix system calls have survived this test of time; most of them are just as useful and applicable today as they were 30 years ago!</p>
<h4 id="verifying-the-parameters">Verifying the Parameters</h4>
<p>System calls must carefully verify all their parameters to ensure that they are valid, legal and correct to guarantee the system’s security and stability. [p75]</p>
<p>One of the most important checks is the validity of any pointers that the user provides. Before following a pointer into user-space, the system must ensure that:</p>
<ul>
<li>The pointer points to a region of memory in user-space. Processes must not be able to trick the kernel into reading data in kernel-space on their behalf.</li>
<li>The pointer points to a region of memory in the process’s address space.The process must not be able to trick the kernel into reading someone else’s data.</li>
<li>The process must not be able to bypass memory access restrictions. If reading, the memory is marked readable. If writing, the memory is marked writable. If executing, the memory is marked executable.</li>
</ul>
<p>The kernel provides two methods for performing the requisite checks and the desired copy to and from user-space. <u>Note kernel code must never blindly follow a pointer into user-space. One of these two methods must always be used.</u></p>
<ul>
<li><code>copy_to_user()</code> is for writing into user-space. It takes three parameters:<ul>
<li>The first argument is the destination memory address in the process’s address space.</li>
<li>The second argument is the source pointer in kernel-space.</li>
<li>The third argument is the size in bytes of the data to copy.</li>
</ul>
</li>
<li><code>copy_from_user()</code> is for reading from user-space. It is analogous to <code>copy_to_user()</code>. The function reads from the second parameter into the first parameter the number of bytes specified in the third parameter.</li>
</ul>
<p>Both of these functions return the number of bytes they failed to copy on error. On success, they return zero. It is standard for the syscall to return <code>-EFAULT</code> in the case of such an error.</p>
<p>The following example <code>silly_copy()</code> uses both <code>copy_from_user()</code> and <code>copy_to_user()</code>. It copies data from its first parameter into its second. This is suboptimal in that it involves an intermediate and extraneous copy into kernel-space for no gain. But it helps illustrate the point:</p>
<div class="codehilite"><pre><span class="cm">/*</span>
<span class="cm">* silly_copy - pointless syscall that copies the len bytes from</span>
<span class="cm">* ‘src’ to ‘dst’ using the kernel as an intermediary in the copy.</span>
<span class="cm">* Intended as an example of copying to and from the kernel.</span>
<span class="cm">*/</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">silly_copy</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">;</span>

    <span class="cm">/* copy src, which is in the user’s address space, into buf */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

    <span class="cm">/* copy buf into dst, which is in the user’s address space */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

    <span class="cm">/* return amount of data copied */</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Both <code>copy_to_user()</code> and <code>copy_from_user()</code> may block. This occurs, for example, if the page containing the user data is not in physical memory but is swapped to disk. In that case, the process sleeps until the page fault handler can bring the page from the swap file on disk into physical memory.</p>
<p>A final possible check is for valid permission. In older versions of Linux, it was standard for syscalls that require root privilege to use <code>suser()</code>. This function merely checked whether a user was root; this is now removed and a finer-grained “capabilities” system is in place.</p>
<p>The new system enables specific access checks on specific resources. A call to <code>capable()</code> with a valid capabilities flag returns nonzero if the caller holds the specified capability and zero otherwise. For example, <code>capable(CAP_SYS_NICE)</code> checks whether the caller has the ability to modify nice values of other processes. By default, the superuser possesses all capabilities and nonroot possesses none.</p>
<p>The following example is the <code>reboot()</code> system call. Note how its first step is ensuring that the calling process has the <code>CAP_SYS_REBOOT</code>. If that one conditional statement were removed, any process could reboot the system.</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/kernel/sys.c#L368">kernel/sys.c#L368</a></small></p>
<div class="codehilite"><pre><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">reboot</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">magic1</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">magic2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
        <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* We only trust the superuser with rebooting the system. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_BOOT</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

    <span class="cm">/* For safety, we require &quot;magic&quot; arguments. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">magic1</span> <span class="o">!=</span> <span class="n">LINUX_REBOOT_MAGIC1</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">magic2</span> <span class="o">!=</span> <span class="n">LINUX_REBOOT_MAGIC2</span> <span class="o">&amp;&amp;</span>
                    <span class="n">magic2</span> <span class="o">!=</span> <span class="n">LINUX_REBOOT_MAGIC2A</span> <span class="o">&amp;&amp;</span>
            <span class="n">magic2</span> <span class="o">!=</span> <span class="n">LINUX_REBOOT_MAGIC2B</span> <span class="o">&amp;&amp;</span>
                    <span class="n">magic2</span> <span class="o">!=</span> <span class="n">LINUX_REBOOT_MAGIC2C</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

    <span class="cm">/* Instead of trying to make the power_off code look like</span>
<span class="cm">     * halt when pm_power_off is not set do it the easy way.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">LINUX_REBOOT_CMD_POWER_OFF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pm_power_off</span><span class="p">)</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">LINUX_REBOOT_CMD_HALT</span><span class="p">;</span>

    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reboot_mutex</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_RESTART</span><span class="p">:</span>
        <span class="n">kernel_restart</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_CAD_ON</span><span class="p">:</span>
        <span class="n">C_A_D</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_CAD_OFF</span><span class="p">:</span>
        <span class="n">C_A_D</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_HALT</span><span class="p">:</span>
        <span class="n">kernel_halt</span><span class="p">();</span>
        <span class="n">do_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">panic</span><span class="p">(</span><span class="s">&quot;cannot halt&quot;</span><span class="p">);</span>

    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_POWER_OFF</span><span class="p">:</span>
        <span class="n">kernel_power_off</span><span class="p">();</span>
        <span class="n">do_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_RESTART2</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strncpy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">buffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

        <span class="n">kernel_restart</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_KEXEC</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">kernel_kexec</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HIBERNATION</span>
    <span class="k">case</span> <span class="nl">LINUX_REBOOT_CMD_SW_SUSPEND</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">hibernate</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reboot_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>See <code>&lt;linux/capability.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/capability.h">include/linux/capability.h</a>) for a list of all capabilities and what rights they entail.</p>
<h3 id="system-call-context">System Call Context</h3>
<p>The kernel is in process context during the execution of a system call (<a href="../ch3/#process-context">Chapter 3</a>). The <code>current</code> pointer points to the current task, which is the process that issued the syscall.</p>
<p>In process context, the kernel is capable of sleeping (for example, if the system call blocks on a call or explicitly calls <code>schedule()</code>) and is fully preemptible. These two points are important:</p>
<ol>
<li><strong>The capability to sleep</strong> means that system calls can make use of the majority of the kernel’s functionality.<ul>
<li>The capability to sleep greatly simplifies kernel programming (<a href="../ch7/">Chapter 7</a>)</li>
<li>Interrupt handlers cannot sleep and thus are much more limited in what they can do than system calls running in process context.</li>
</ul>
</li>
<li>The fact that <strong>process context is preemptible</strong> implies that, like user-space, the current task may be preempted by another task.<ul>
<li><u>Because the new task may then execute the same system call, care must be exercised to ensure that system calls are reentrant.</u> This is the same concern that symmetrical multiprocessing introduces. (Synchronizing reentrancy is covered in <a href="../ch9/">Chapter 9</a>).</li>
</ul>
</li>
</ol>
<p><u>When the system call returns, control continues in <code>system_call()</code>, which ultimately switches to user-space and continues the execution of the user process.</u> (<a href="../figure_5.2.png">Figure 5.2</a>)</p>
<h4 id="final-steps-in-binding-a-system-call">Final Steps in Binding a System Call</h4>
<p>It is trivial to register a (official) system call after it is written:</p>
<ol>
<li>Add an entry to the end of the system call table. This needs to be done for each architecture that supports the system call. The position of the syscall in the table, starting at zero, is its system call number.</li>
<li>For each supported architecture, define the syscall number in <code>&lt;asm/unistd.h&gt;</code>.</li>
<li>Compile the syscall into the kernel image (as opposed to compiling as a module). This can be as simple as putting the system call in a relevant file in <code>kernel/</code>, such as <code>sys.c</code>, which is home to miscellaneous system calls.</li>
</ol>
<p>For example of a fictional system call <code>foo()</code>. We want to add <code>sys_foo()</code> to the system call table. For most architectures, the table is located in <code>entry.S</code> and looks like this (The new system call is then appended to the tail of this list):</p>
<div class="codehilite"><pre><span class="n">ENTRY</span><span class="p">(</span><span class="n">sys_call_table</span><span class="p">)</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_restart_syscall</span> <span class="cm">/* 0 */</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_exit</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_fork</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_read</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_write</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_open</span> <span class="cm">/* 5 */</span>
<span class="p">...</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_eventfd2</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_epoll_create1</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_dup3</span> <span class="cm">/* 330 */</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_pipe2</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_inotify_init1</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_preadv</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_pwritev</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_rt_tgsigqueueinfo</span> <span class="cm">/* 335 */</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_perf_event_open</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_recvmmsg</span>
<span class="p">.</span><span class="kt">long</span> <span class="n">sys_foo</span>
</pre></div>


<p>Though not explicitly specified, the system call is then given the next subsequent syscall number (338, in this case).</p>
<ul>
<li>For each architecture you want to support, the system call must be added to the architecture’s system call table.</li>
<li>The system call does not need to receive the same syscall number under each architecture, as the system call number is part of the architecture’s unique ABI.</li>
<li>Usually, you would want to make the system call available to each architecture.</li>
<li>Note the convention of placing the number in a comment every five entries; this makes it easy to find out which syscall is assigned which number.</li>
</ul>
<p>Next, the system call number is added to <code>&lt;asm/unistd.h&gt;</code> like below:</p>
<div class="codehilite"><pre><span class="cm">/*</span>
<span class="cm">* This file contains the system call numbers.</span>
<span class="cm">*/</span>
<span class="cp">#define __NR_restart_syscall 0</span>
<span class="cp">#define __NR_exit 1</span>
<span class="cp">#define __NR_fork 2</span>
<span class="cp">#define __NR_read 3</span>
<span class="cp">#define __NR_write 4</span>
<span class="cp">#define __NR_open 5</span>
<span class="p">...</span>
<span class="cp">#define __NR_signalfd4 327</span>
<span class="cp">#define __NR_eventfd2 328</span>
<span class="cp">#define __NR_epoll_create1 329</span>
<span class="cp">#define __NR_dup3 330</span>
<span class="cp">#define __NR_pipe2 331</span>
<span class="cp">#define __NR_inotify_init1 332</span>
<span class="cp">#define __NR_preadv 333</span>
<span class="cp">#define __NR_pwritev 334</span>
<span class="cp">#define __NR_rt_tgsigqueueinfo 335</span>
<span class="cp">#define __NR_perf_event_open 336</span>
<span class="cp">#define __NR_recvmmsg 337</span>
<span class="cp">#define __NR_foo</span>
</pre></div>


<p>Finally, the actual <code>foo()</code> system call is implemented. Because the system call must be compiled into the core kernel image in all configurations, in this example we define it in <code>kernel/sys.c</code>. You should put it wherever the function is most relevant; for example, if the function is related to scheduling, you could define it in <code>kernel/sched.c</code>.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cm">/*</span>
<span class="cm">* sys_foo – everyone’s favorite system call.</span>
<span class="cm">*</span>
<span class="cm">* Returns the size of the per-process kernel stack.</span>
<span class="cm">*/</span>
<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">THREAD_SIZE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Boot this kernel and user-space can invoke the <code>foo()</code> system call</p>
<h4 id="accessing-the-system-call-from-user-space">Accessing the System Call from User-Space</h4>
<p>The C library provides support for system calls. User applications can pull in function prototypes from the standard headers and link with the C library to use your system call. [p81]</p>
<p>Linux provides a set of macros for wrapping access to system calls. It sets up the register contents and issues the trap instructions. These macros are named <code>_syscalln()</code>, where <em>n</em> is between 0 and 6. The number corresponds to the number of parameters passed into the syscall, because the macro needs to know how many parameters to push into registers.</p>
<p>For example, consider the system call <code>open()</code>, defined as</p>
<div class="codehilite"><pre><span class="kt">long</span> <span class="n">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
</pre></div>


<p>The syscall macro to use this system call without explicit library support would be:</p>
<div class="codehilite"><pre><span class="cp">#define __NR_open 5</span>
<span class="n">_syscall3</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">open</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
</pre></div>


<p>The application can simply call <code>open()</code>.</p>
<p>An macro has 2 + 2 × <em>n</em> parameters:</p>
<ul>
<li>The first parameter corresponds to the return type of the syscall.</li>
<li>The second is the name of the system call.</li>
<li>The remainder are type and name for each parameter in order of the system call.</li>
</ul>
<p>The <code>__NR_open</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/arch/x86/include/asm/unistd_64.h#L19">arch/x86/include/asm/unistd_64.h#L19</a>) is defined in <code>&lt;asm/unistd.h&gt;</code>; it is the system call number.</p>
<p><u>The <code>_syscall3</code> macro expands into a C function with inline assembly;</u> the assembly performs the steps discussed in the previous section to push the system call number and parameters into the correct registers and issue the software interrupt to trap into the kernel. <u>Placing this macro in an application is all that is required to use the <code>open()</code> system call.</u></p>
<p>For example of the <code>foo()</code> system call, we can use it from an application like this:</p>
<div class="codehilite"><pre><span class="cp">#define __NR_foo 283</span>
<span class="n">__syscall0</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">stack_size</span><span class="p">;</span>
    <span class="n">stack_size</span> <span class="o">=</span> <span class="n">foo</span> <span class="p">();</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;The kernel stack size is %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="why-not-to-implement-a-system-call">Why Not to Implement a System Call</h4>
<p>Adding new syscall is not encouraged, and you should otherwise exercise caution and restraint in adding one. [p82]o</p>
<p>The followings are pros and cons of implementing a new interface as a syscall:</p>
<ul>
<li>Pros:<ul>
<li>System calls are simple to implement and easy to use.</li>
<li>System call performance on Linux is fast.</li>
</ul>
</li>
<li>Cons:<ul>
<li>You need a syscall number, which needs to be officially assigned to you.</li>
<li>After the system call is in a stable series kernel, it is written in stone. The interface cannot change without breaking user-space applications.</li>
<li>Each architecture needs to separately register the system call and support it.</li>
<li>System calls are not easily used from scripts and cannot be accessed directly from the filesystem.</li>
<li>Because you need an assigned syscall number, it is hard to maintain and use a system call outside of the master kernel tree.</li>
<li>For simple exchanges of information, a system call is overkill.</li>
</ul>
</li>
</ul>
<p>The alternatives to implementing a syscall:</p>
<ul>
<li>Implement a device node and <code>read()</code> and <code>write()</code> to it. Use <code>ioctl()</code> to manipulate specific settings or retrieve specific information.</li>
<li>Certain interfaces, such as semaphores, can be represented as file descriptors and manipulated as such.</li>
<li>Add the information as a file to the appropriate location in sysfs</li>
</ul>
<p>The slow rate of addition of new system calls is a sign that Linux is a relatively stable and feature-complete operating system. [p83]</p>
<h3 id="conclusion">Conclusion</h3>
<p>In this chapter discusses what system calls are and how they relate to library calls and the application programming interface (API). This includes how the Linux kernel implements system calls and the chain of events required to execute a system call: trapping into the kernel, transmitting the syscall number and any arguments, executing the correct system call function, and returning to user-space with the syscall’s return value. [p83]</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>