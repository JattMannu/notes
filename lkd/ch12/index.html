<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/lkd/ch12/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 12. Memory Management - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">PER <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../per/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch1/">Chapter 1. A Tutorial Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch6/">Chapter 6. Functions and Functional Programming</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch7/">Chapter 7. Classes and Object-Oriented Programming</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch15/">Chapter 15. Data Structures, Algorithms, and Code Simplification</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TWGR <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../twgr/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../twgr/ch1/">Chapter 1. Bootstrapping your Ruby literacy</a>
                        </li>
                      
                        <li>
                            <a href="../../twgr/ch2/">Chapter 2. Objects, methods, and local variables</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">SPEC <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../spec/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch2/">Chapter 2. Methodology</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch3/">Chapter 3. Operating Systems</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch4/">Chapter 4. Observability Tools</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch5/">Chapter 5. Applications</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch6/">Chapter 6. CPUs</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch7/">Chapter 7. Memory</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch8/">Chapter 8. File Systems</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch9/">Chapter 9. Disks</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch10/">Chapter 10. Network</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">BD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../bd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../bd/ch1/">Chapter 1. A new paradigm for Big Data</a>
                        </li>
                      
                        <li>
                            <a href="../../bd/ch2/">Chapter 2. Data model for Big Data</a>
                        </li>
                      
                        <li>
                            <a href="../../bd/ch3/">Chapter 3. Data model for Big Data: Illustration</a>
                        </li>
                      
                    </ul>
                </li>
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/lkd/ch12.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-12-memory-management">Chapter 12. Memory Management</a></li>
        
    
        <li class="main "><a href="#page">Page</a></li>
        
    
        <li class="main "><a href="#zones">Zones</a></li>
        
    
        <li class="main "><a href="#getting-pages">Getting Pages</a></li>
        
            <li><a href="#getting-zeroed-pages">Getting Zeroed Pages</a></li>
        
            <li><a href="#freeing-pages">Freeing Pages</a></li>
        
    
        <li class="main "><a href="#kmalloc">kmalloc()</a></li>
        
            <li><a href="#gfp_mask-flags">gfp_mask Flags</a></li>
        
            <li><a href="#kfree">kfree()</a></li>
        
    
        <li class="main "><a href="#vmalloc">vmalloc()</a></li>
        
    
        <li class="main "><a href="#slab-layer">Slab Layer</a></li>
        
            <li><a href="#free-lists">Free Lists *</a></li>
        
            <li><a href="#slab-layer-generic-data-structure-caching-layer">Slab Layer: generic data structure-caching layer *</a></li>
        
            <li><a href="#design-of-the-slab-layer">Design of the Slab Layer</a></li>
        
            <li><a href="#slab-allocator-interface">Slab Allocator Interface</a></li>
        
            <li><a href="#example-of-using-the-slab-allocator">Example of Using the Slab Allocator</a></li>
        
    
        <li class="main "><a href="#statically-allocating-on-the-stack">Statically Allocating on the Stack</a></li>
        
            <li><a href="#single-page-kernel-stacks">Single-Page Kernel Stacks</a></li>
        
            <li><a href="#playing-fair-on-the-stack">Playing Fair on the Stack</a></li>
        
    
        <li class="main "><a href="#high-memory-mappings">High Memory Mappings</a></li>
        
            <li><a href="#permanent-mappings">Permanent Mappings</a></li>
        
            <li><a href="#temporary-mappings">Temporary Mappings</a></li>
        
    
        <li class="main "><a href="#per-cpu-allocations">Per-CPU Allocations</a></li>
        
    
        <li class="main "><a href="#the-new-percpu-interface">The New percpu Interface</a></li>
        
            <li><a href="#per-cpu-data-at-compile-time">Per-CPU Data at Compile-Time</a></li>
        
            <li><a href="#per-cpu-data-at-runtime">Per-CPU Data at Runtime</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-12-memory-management"><strong>Chapter 12. Memory Management</strong></h3>
<p>Unlike user-space, the kernel is not always afforded the capability to easily allocate memory. This chapter discusses how the kernel handles memory and the methods used to obtain memory inside the kernel.</p>
<h3 id="page">Page</h3>
<p>To kernel, physical pages are the basic unit of memory management. Although the processor’s smallest addressable unit is a byte or a word, the <a href="https://en.wikipedia.org/wiki/Memory_management_unit">memory management unit</a> (MMU, the hardware that manages memory and performs virtual to physical address translations) typically deals in pages. Therefore, the MMU maintains the system’s page tables with page-sized granularity. In terms of virtual memory, pages are the smallest unit.</p>
<p>Each architecture defines its own page size. Many architectures even support multiple page sizes.</p>
<ul>
<li>Most 32-bit architectures have 4KB pages;</li>
<li>Most 64-bit architectures have 8KB pages.</li>
</ul>
<p>This implies that on a machine with 4KB pages and 1GB of memory, physical memory is divided into 262,144 distinct pages.</p>
<p>The kernel represents every physical page on the system with a <code>struct page</code> structure.  This structure is defined in <code>&lt;linux/mm_types.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mm_types.h">include/linux/mm_types.h</a>). The following is a simplified the definition (two confusing unions are removed):</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mm_types.h#L34">include/linux/mm_types.h#L34</a></small></p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">page</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">_count</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">_mapcount</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
    <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">virtual</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<ul>
<li>The <code>flags</code> field stores the status of the page, such as whether the page is dirty or whether it is locked in memory. Bit flags represent the various values, so at least 32 different flags are simultaneously available. The flag values are defined in <code>&lt;linux/page-flags.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/page-flags.h">include/linux/page-flags.h</a>).</li>
<li>The <code>_count</code> field stores the usage count of the page: how many references there are to this page.<ul>
<li>If <code>_count</code>'s value is negative one (-1) indicates that no one is using the page, and it becomes available for use in a new allocation.</li>
<li>Kernel code should not check this field directly but instead use the function <code>page_count()</code>, which takes a page structure as its sole parameter. <code>page_count()</code> returns zero to indicate free and a positive nonzero integer when the page is in use.</li>
<li>A page may be used by the page cache (in which case the <code>mapping</code> field points to the <code>address_space</code> object associated with this page), as private data (pointed at by <code>private</code>), or as a mapping in a process’s page table.</li>
</ul>
</li>
<li>The <code>virtual</code> field is the page’s virtual address. Normally, this is simply the address of the page in virtual memory.<ul>
<li>Some memory (called high memory) is not permanently mapped in the kernel’s address space. In that case, this field is <code>NULL</code>, and the page must be dynamically mapped if needed.</li>
</ul>
</li>
</ul>
<p>The <code>page</code> structure is associated with physical pages, not virtual pages; what the structure describes is transient at best. Even if the data contained in the page continues to exist, it might not always be associated with the same <code>page</code> structure because of swapping and so on. <u>The kernel uses this data structure to describe the associated physical page. The data structure’s goal is to describe physical memory, not the data contained therein.</u></p>
<p>The kernel uses this structure to keep track of all the pages in the system, because the kernel needs to know whether a page is free (whether the page is not allocated). If a page is not free, the kernel needs to know who owns the page. Possible owners include (but not limited to):</p>
<ul>
<li>User-space processes,</li>
<li>Dynamically allocated kernel data,</li>
<li>Static kernel code,</li>
<li>Page cache.</li>
</ul>
<p>Since an instance of this structure is allocated for each physical page in the system. How bad (or good) the space consumption is from all these pages?  Assume <code>struct page</code> consumes 40 bytes of memory, the system has 8KB physical pages, and the system has 4GB of physical memory. In that case, there are about 524,288 pages and page structures on the system. The page structures consume 20MB: perhaps a surprisingly large number in absolute terms, but only a small fraction of a percent relative to the system’s 4GB. This is not too high a cost for managing all the system’s physical pages.</p>
<h3 id="zones">Zones</h3>
<p>The kernel cannot treat all pages as identical due to hardware limitations. Some pages, because of their physical address in memory, cannot be used for certain tasks. Thus, the kernel divides pages into different <em>zones</em>. The kernel uses the zones to group pages of similar properties.</p>
<p>Linux has to deal with two shortcomings of hardware with respect to memory addressing:</p>
<ul>
<li>Some hardware devices can perform <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> (direct memory access) to only certain memory addresses.</li>
<li>Some architectures can physically addressing larger amounts of memory than they can virtually address. Consequently, some memory is not permanently mapped into the kernel address space.</li>
</ul>
<p>Due to these contraints, Linux has four primary memory zones:</p>
<ul>
<li><code>ZONE_DMA</code>. This zone contains pages that can undergo DMA.</li>
<li><code>ZONE_DMA32</code>. Like ZOME_DMA, this zone contains pages that can undergo DMA. Unlike <code>ZONE_DMA</code>, these pages are accessible only by 32-bit devices. On some architectures, this zone is a larger subset of memory.</li>
<li><code>ZONE_NORMAL</code>. This zone contains normal, regularly mapped, pages.</li>
<li><code>ZONE_HIGHMEM</code>. This zone contains "high memory", which are pages not permanently mapped into the kernel’s address space.</li>
</ul>
<p>These zones are defined in <code>&lt;linux/mmzone.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mmzone.h">include/linux/mmzone.h</a>)</p>
<p>The layout of the memory zones is architecture-dependent. For example:</p>
<ul>
<li>Some architectures can perform DMA into any memory address. In those architectures, <code>ZONE_DMA</code> is empty and <code>ZONE_NORMAL</code> is used for allocations regardless of their use.</li>
<li>On the x86 architecture, <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a> devices cannot perform DMA into the full 32-bit address space1 because ISA devices can access only the first 16MB of physical memory. Consequently, <code>ZONE_DMA</code> on x86 consists of all memory in the range 0MB–16MB.</li>
</ul>
<p><code>ZONE_HIGHMEM</code> works similarly. On 32-bit x86 systems, <code>ZONE_HIGHMEM</code> is all memory above the physical 896MB mark. On other architectures, <code>ZONE_HIGHMEM</code> is empty because all memory is directly mapped. The memory contained in <code>ZONE_HIGHMEM</code> is called <strong>high memory</strong>. The rest of the system’s memory is called <strong>low memory</strong>.</p>
<p><code>ZONE_NORMAL</code> is the remainder after the previous two zones claim their requisite shares. On x86, <code>ZONE_NORMAL</code> is all physical memory from 16MB to 896MB. On other architectures, <code>ZONE_NORMAL</code> is all available memory.</p>
<p>The following table is a listing of each zone and its consumed pages on x86-32.</p>
<table>
<thead>
<tr>
<th>Zone</th>
<th>Description</th>
<th>Physical Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ZONE_DMA</code></td>
<td>DMA-able pages</td>
<td>&lt; 16MB</td>
</tr>
<tr>
<td><code>ZONE_NORMAL</code></td>
<td>Normally addressable pages</td>
<td>16–896MB</td>
</tr>
<tr>
<td><code>ZONE_HIGHMEM</code></td>
<td>Dynamically mapped pages</td>
<td>&gt; 896MB</td>
</tr>
</tbody>
</table>
<p>Linux partitions pages into zones to have a pooling in place to satisfy allocations as needed. For example, with a <code>ZONE_DMA</code> pool, the kernel has the capability to satisfy memory allocations needed for DMA. If such memory is needed, the kernel can simply pull the required number of pages from <code>ZONE_DMA</code>. The zones do not have any physical relevance but are simply logical groupings used by the kernel to keep track of pages.</p>
<p>Although some allocations may require pages from a particular zone, other allocations may pull from multiple zones. For example:</p>
<ul>
<li>An allocation for DMA-able memory must originate from <code>ZONE_DMA</code></li>
<li>A normal allocation can come from <code>ZONE_DMA</code> or <code>ZONE_NORMAL</code> but not both; allocations cannot cross zone boundaries. The kernel prefers to satisfy normal allocations from the normal zone to save the pages in <code>ZONE_DMA</code> for allocations that need it. [p234]</li>
</ul>
<p>Not all architectures define all zones. For example, a 64-bit architecture such as Intel’s x86-64 can fully map and handle 64-bits of memory.Thus, x86-64 has no <code>ZONE_HIGHMEM</code> and all physical memory is contained within <code>ZONE_DMA</code> and <code>ZONE_NORMAL</code>.</p>
<p>Each zone is represented by struct zone, which is defined in <code>&lt;linux/mmzone.h&gt;</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mmzone.h#L280">include/linux/mmzone.h#L280</a></small></p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">zone</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">watermark</span><span class="p">[</span><span class="n">NR_WMARK</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lowmem_reserve</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">per_cpu_pageset</span> <span class="n">pageset</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">free_area</span> <span class="n">free_area</span><span class="p">[</span><span class="n">MAX_ORDER</span><span class="p">]</span>
    <span class="n">spinlock_t</span> <span class="n">lru_lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zone_lru</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_saved_scan</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">lru</span><span class="p">[</span><span class="n">NR_LRU_LISTS</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">zone_reclaim_stat</span> <span class="n">reclaim_stat</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_scanned</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">atomic_long_t</span> <span class="n">vm_stat</span><span class="p">[</span><span class="n">NR_VM_ZONE_STAT_ITEMS</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">prev_priority</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inactive_ratio</span><span class="p">;</span>
    <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wait_table</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_hash_nr_entries</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_bits</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">zone_pgdat</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_start_pfn</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spanned_pages</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">present_pages</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<ul>
<li>The <code>lock</code> field is a spin lock that protects the structure from concurrent access. It protects just the structure and not all the pages that reside in the zone. A specific lock does not protect individual pages, although parts of the kernel may lock the data that happens to reside in said pages.</li>
<li>The <code>watermark</code> array holds the minimum, low, and high watermarks for this zone. The kernel uses watermarks to set benchmarks for suitable per-zone memory consumption. [p235]</li>
<li>The <code>name</code> field is a NULL-terminated string representing the name of this zone. The kernel initializes this value during boot in <a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/page_alloc.c">mm/page_alloc.c</a>, and the three zones are given the names DMA, Normal, and HighMem.</li>
</ul>
<h3 id="getting-pages">Getting Pages</h3>
<p>This section discusses the interfaces the kernel implements to enable you to allocate and free memory within the kernel.</p>
<p>The kernel provides one low-level mechanism for requesting memory, along with several interfaces to access it. All these interfaces allocate memory with page-sized granularity and are declared in <code>&lt;linux/gfp.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/gfp.h">include/linux/gfp.h</a>). The core function is:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
</pre></div>


<p>This allocates 2<sup>order</sup> (<code>1 &lt;&lt; order</code>) contiguous physical pages and returns a pointer to the first page’s <code>page</code> structure; on error it returns <code>NULL</code>.</p>
<p>You can convert a given page to its logical address with the function:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span> <span class="n">page_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
</pre></div>


<p>This returns a pointer to the logical address where the given physical page currently resides.</p>
<p>If you have no need for the actual <code>struct page</code>, you can call:</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
</pre></div>


<p>This function works the same as <code>alloc_pages()</code>, except that it directly returns the logical address of the first requested page. Because the pages are contiguous, the other pages simply follow from the first.</p>
<p>If you need only one page, two functions are implemented as wrappers to save you a bit of typing:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
</pre></div>


<p>These functions work the same but pass zero for the order (2<sup>0</sup> = one page).</p>
<h4 id="getting-zeroed-pages">Getting Zeroed Pages</h4>
<p>If you need the returned page filled with zeros, use the function:</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gfp_mask</span><span class="p">)</span>
</pre></div>


<p>This function works the same as <code>__get_free_page()</code>, except that the allocated page is then zero-filled (every bit of every byte is unset). This is useful for pages given to userspace because the random garbage in an allocated page is not so random; it might contain sensitive data. All data must be zeroed or otherwise cleaned before it is returned to userspace to ensure system security is not compromised.</p>
<p>The following table is a listing of all the low-level page allocation methods.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alloc_page(gfp_mask)</code></td>
<td>Allocates a single page and returns a pointer to its first page’s <code>page</code> structure</td>
</tr>
<tr>
<td><code>alloc_pages(gfp_mask, order)</code></td>
<td>Allocates 2<sup>order</sup> pages and returns a pointer to the first page’s <code>page</code> structure</td>
</tr>
<tr>
<td><code>__get_free_page(gfp_mask)</code></td>
<td>Allocates a single page and returns a pointer to its logical address</td>
</tr>
<tr>
<td><code>__get_free_pages(gfp_mask, order)</code></td>
<td>Allocates 2<sup>order</sup> pages and returns a pointer to the first page’s logical address</td>
</tr>
<tr>
<td><code>get_zeroed_page(gfp_mask)</code></td>
<td>Allocates a single page, zero its contents and returns a pointer to its logical address</td>
</tr>
</tbody>
</table>
<h4 id="freeing-pages">Freeing Pages</h4>
<p>A family of functions enables you to free allocated pages when you no longer need them:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">__free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">free_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">free_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
</pre></div>


<p>Be careful to free only pages you allocate. Passing the wrong <code>struct page</code> or address, or the incorrect order, can result in corruption. [p237]</p>
<p>For example, we want to allocate eight pages:</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
<span class="n">page</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* insufficient memory: you must handle this error! */</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* &#39;page&#39; is now the address of the first of eight contiguous pages ... */</span>
</pre></div>


<p>Free the eight pages, after we are done using them:</p>
<div class="codehilite"><pre><span class="n">free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">* our pages are now freed and we should no</span>
<span class="cm">* longer access the address stored in &#39;page&#39;</span>
<span class="cm">*/</span>
</pre></div>


<p>The <code>GFP_KERNEL</code> parameter is an example of a <code>gfp_mask</code> flag (discussed shortly).</p>
<p>A kernel allocation can fail, and your code must check for and handle such errors after the call to <code>__get_free_pages()</code>. <u>It therefore often makes sense to allocate your memory at the start of the routine to make handling the error easier.</u> [p237]</p>
<p>These low-level page functions are useful when you need page-sized chunks of physically contiguous pages, especially if you need exactly a single page or two. For more general byte-sized allocations, the kernel provides <code>kmalloc()</code>.</p>
<h3 id="kmalloc"><code>kmalloc()</code></h3>
<p>The <code>kmalloc()</code> function is similar to user-space’s <code>malloc()</code>, with the exception of the additional flags parameter. The <code>kmalloc()</code> function is a simple interface for obtaining kernel memory in byte-sized chunks. If you need whole pages, the previously discussed interfaces might be a better choice. For most kernel allocations, <code>kmalloc()</code> is the preferred interface.</p>
<p>The function is declared in <code>&lt;linux/slab.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab.h">include/linux/slab.h</a>):</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab_def.h#L128">include/linux/slab_def.h#L128</a></small></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span> <span class="n">kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
</pre></div>


<p>The <code>kmalloc()</code> function returns a pointer to a region of memory that is at least <code>size</code> bytes in length. It may allocate more than you asked, although you have no way of knowing how much more. Because the kernel allocator is page-based, some allocations may be rounded up to fit within the available memory. The kernel never returns less memory than requested. If the kernel is unable to find at least the requested amount, the allocation fails and the function returns <code>NULL</code>. The region of memory allocated is physically contiguous. Kernel allocations always succeed, unless an insufficient amount of memory is available. Thus, you must check for <code>NULL</code> after all calls to <code>kmalloc()</code> and handle the error appropriately.</p>
<p>For example:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">dog</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dog</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
    <span class="cm">/* handle error ... */</span>
</pre></div>


<p>If the <code>kmalloc()</code> call succeeds, <code>p</code> now points to a block of memory that is at least the requested size.The <code>GFP_KERNEL</code> flag specifies the behavior of the memory allocator while trying to obtain the memory to return to the caller of <code>kmalloc()</code>.</p>
<h4 id="gfp_mask-flags"><code>gfp_mask</code> Flags</h4>
<p>Flags are represented by the <code>gfp_t</code> type, which is defined in <code>&lt;linux/types.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/types.h#L179">include/linux/types.h#L179</a>) as an <code>unsigned int</code>. <em>gfp</em> stands for <code>__get_free_pages()</code> (discussed earlier).</p>
<p>The flags are broken up into three categories:</p>
<ul>
<li><strong>Action modifiers</strong> specify <em>how</em> the kernel is supposed to allocate the requested memory. In certain situations, only certain methods can be employed to allocate memory. For example, interrupt handlers must instruct the kernel not to sleep (because interrupt handlers cannot reschedule) while allocating memory.</li>
<li><strong>Zone modifiers</strong> specify from <em>where</em> (from which zones) to allocate memory.</li>
<li><strong>Type</strong> specify a combination of action and zone modifiers for a certain type of memory allocation. This simplifies the specification of multiple modifiers; instead of providing a combination of action and zone modifiers, you can specify just one type flag. The <code>GFP_KERNEL</code> is a type flag, which is used for code in process context inside the kernel.</li>
</ul>
<h5 id="action-modifiers"><strong>Action Modifiers</strong></h5>
<p>All the flags are declared in <code>&lt;linux/gfp.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/gfp.h">include/linux/gfp.h</a>). The file
<code>&lt;linux/slab.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab.h">include/linux/slab.h</a>) includes this header.</p>
<p>The table below is a list of the action modifiers.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__GFP_WAIT</code></td>
<td>The allocator can sleep.</td>
</tr>
<tr>
<td><code>__GFP_HIGH</code></td>
<td>The allocator can access emergency pools.</td>
</tr>
<tr>
<td><code>__GFP_IO</code></td>
<td>The allocator can start disk I/O.</td>
</tr>
<tr>
<td><code>__GFP_FS</code></td>
<td>The allocator can start filesystem I/O.</td>
</tr>
<tr>
<td><code>__GFP_COLD</code></td>
<td>The allocator should use cache cold pages.</td>
</tr>
<tr>
<td><code>__GFP_NOWARN</code></td>
<td>The allocator does not print failure warnings.</td>
</tr>
<tr>
<td><code>__GFP_REPEAT</code></td>
<td>The allocator repeats the allocation if it fails, but the allocation can potentially fail.</td>
</tr>
<tr>
<td><code>__GFP_NOFAIL</code></td>
<td>The allocator indefinitely repeats the allocation. The allocation cannot fail.</td>
</tr>
<tr>
<td><code>__GFP_NORETRY</code></td>
<td>The allocator never retries if the allocation fails.</td>
</tr>
<tr>
<td><code>__GFP_NOMEMALLOC</code></td>
<td>The allocator does not fall back on reserves.</td>
</tr>
<tr>
<td><code>__GFP_HARDWALL</code></td>
<td>The allocator enforces "hardwall" <a href="http://man7.org/linux/man-pages/man7/cpuset.7.html">cpuset</a> boundaries.</td>
</tr>
<tr>
<td><code>__GFP_RECLAIMABLE</code></td>
<td>The allocator marks the pages reclaimable.</td>
</tr>
<tr>
<td><code>__GFP_COMP</code></td>
<td>The allocator adds compound.</td>
</tr>
</tbody>
</table>
<p>These allocations can be specified together. For example:</p>
<div class="codehilite"><pre><span class="n">ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">__GFP_WAIT</span> <span class="o">|</span> <span class="n">__GFP_IO</span> <span class="o">|</span> <span class="n">__GFP_FS</span><span class="p">);</span>
</pre></div>


<p>This call instructs the page allocator (ultimately <code>alloc_pages()</code>) that the allocation can block, perform I/O, and perform filesystem operations. This gives the kernel great freedom in how it can find the free memory to satisfy the allocation.</p>
<h5 id="zone-modifiers"><strong>Zone Modifiers</strong></h5>
<p>Zone modifiers specify from which memory zone the allocation should originate. Though allocations can be fulfilled from any zone, the kernel prefers <code>ZONE_NORMAL</code> to ensure that the other zones have free pages when they are needed.</p>
<p>There are only three zone modifiers because there are only three zones other than <code>ZONE_NORMAL</code>, as in the following table:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__GFP_DMA</code></td>
<td>Allocates only from <code>ZONE_DMA</code></td>
</tr>
<tr>
<td><code>__GFP_DMA32</code></td>
<td>Allocates only from <code>ZONE_DMA32</code></td>
</tr>
<tr>
<td><code>__GFP_HIGHMEM</code></td>
<td>Allocates from <code>ZONE_HIGHMEM</code> or <code>ZONE_NORMAL</code></td>
</tr>
</tbody>
</table>
<ul>
<li>The <code>__GFP_DMA</code> flag forces the kernel to satisfy the request from <code>ZONE_DMA</code>.</li>
<li>The <code>__GFP_HIGHMEM</code> flag instructs the allocator to satisfy the request from either <code>ZONE_NORMAL</code> or (preferentially) <code>ZONE_HIGHMEM</code>.</li>
</ul>
<p>If neither flag is specified, the kernel fulfills the allocation from either <code>ZONE_DMA</code> or <code>ZONE_NORMAL</code>, with a strong preference to satisfy the allocation from <code>ZONE_NORMAL</code>.</p>
<p>You cannot specify <code>__GFP_HIGHMEM</code> to either <code>__get_free_pages()</code> or <code>kmalloc()</code>, because these both return a logical address, and not a <code>page</code> structure. It is possible that these functions would allocate memory not currently mapped in the kernel’s virtual address space and thus, does not have a logical address. Only <code>alloc_pages()</code> can allocate high memory.</p>
<p>The majoriy of allocations will not specify a zone modifier because <code>ZONE_NORMAL</code> is sufficient.</p>
<h5 id="type-flags"><strong>Type Flags</strong></h5>
<p>The type flags specify the required action and zone modifiers to fulfill a particular type of transaction. Therefore, kernel code tends to use the correct type flag and not specify the myriad of other flags it might need. This is both simpler and less error-prone.</p>
<p>The table below is a list of the type flags:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GFP_ATOMIC</code></td>
<td>The allocation is high priority and must not sleep. This is the flag to use in interrupt handlers, in bottom halves, while holding a spinlock, and in other situations where you cannot sleep.</td>
</tr>
<tr>
<td><code>GFP_NOWAIT</code></td>
<td>Like <code>GFP_ATOMIC</code>, except that the call will not fallback on emergency memory pools. This increases the liklihood of the memory allocation failing.</td>
</tr>
<tr>
<td><code>GFP_NOIO</code></td>
<td>This allocation can block, but must not initiate disk I/O. This is the flag to use in block I/O code when you cannot cause more disk I/O, which might lead to some unpleasant recursion.</td>
</tr>
<tr>
<td><code>GFP_NOFS</code></td>
<td>This allocation can block and can initiate disk I/O, if it must, but it will not initiate a filesystem operation. This is the flag to use in filesystem code when you cannot start another filesystem operation.</td>
</tr>
<tr>
<td><code>GFP_KERNEL</code></td>
<td>This is a normal allocation and might block. This is the flag to use in process context code when it is safe to sleep. The kernel will do whatever it has to do to obtain the memory requested by the caller. This flag should be your default choice.</td>
</tr>
<tr>
<td><code>GFP_USER</code></td>
<td>This is a normal allocation and might block. This flag is used to allocate memory for user-space processes.</td>
</tr>
<tr>
<td><code>GFP_HIGHUSER</code></td>
<td>This is an allocation from <code>ZONE_HIGHMEM</code> and might block. This flag is used to allocate memory for user-space processes.</td>
</tr>
<tr>
<td><code>GFP_DMA</code></td>
<td>This is an allocation from <code>ZONE_DMA</code>. Device drivers that need DMA-able memory use this flag, usually in combination with one of the preceding flags.</td>
</tr>
</tbody>
</table>
<p>The following table shows which modifiers are associated with each type flag:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Modifier Flags</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GFP_NOFS</code></td>
<td><code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO)</code></td>
</tr>
<tr>
<td><code>GFP_KERNEL</code></td>
<td><code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO &#124; &#95;&#95;GFP_FS)</code></td>
</tr>
<tr>
<td><code>GFP_USER</code></td>
<td><code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO &#124; &#95;&#95;GFP_FS)</code></td>
</tr>
<tr>
<td><code>GFP_HIGHUSER</code></td>
<td><code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO &#124; &#95;&#95;GFP_FS &#124; &#95;&#95;GFP_HIGHMEM)</code></td>
</tr>
<tr>
<td><code>GFP_DMA</code></td>
<td><code>__GFP_DMA</code></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>The <code>GFP_KERNEL</code> flag. This flag is used in vast majority of allocations. The resulting allocation is a normal priority allocation that might sleep. Because the call can block, this flag can be used only from process context that can safely reschedule (no locks are held and so on.) Because this flag does not make any stipulations as to how the kernel may obtain the requested memory, the memory allocation has a high probability of succeeding.</p>
</li>
<li>
<p>The <code>GFP_ATOMIC</code> flag. Because this flag specifies a memory allocation that cannot sleep, the allocation is restrictive in the memory it can obtain for the caller. If no sufficiently sized contiguous chunk of memory is available, the kernel is not likely to free memory because it cannot put the caller to sleep. Conversely, the <code>GFP_KERNEL</code> allocation can put the caller to sleep to swap inactive pages to disk, flush dirty pages to disk, and so on. Because <code>GFP_ATOMIC</code> cannot perform any of these actions, it has less of a chance of succeeding (at least when memory is low) compared to <code>GFP_KERNEL</code> allocations. Nonetheless, the <code>GFP_ATOMIC</code> flag is the only option when the current code cannot sleep, such as with interrupt handlers, softirqs, and tasklets.</p>
</li>
</ul>
<p>Allocations initiated with <code>GFP_NOIO</code> and <code>GFP_NOFS</code> might block, but they refrain from performing certain other operations.</p>
<ul>
<li>The <code>GFP_NOIO</code> allocation does not initiate any disk I/O whatsoever to fulfill the request.</li>
<li>The <code>GFP_NOFS</code> allocation might initiate disk I/O, but does not initiate filesystem I/O.</li>
</ul>
<p>They are needed for certain low-level block I/O or filesystem code. For example, <u>a common path in the filesystem code allocated memory without the <code>GFP_NOFS</code> flag, the allocation could result in more filesystem operations, which may beget other allocations. This could continue indefinitely. Such filesystem code that invokes the allocator must ensure that the allocator also does not execute itself, or else the allocation can create a deadlock.</u></p>
<p>The <code>GFP_DMA</code> flag specifes that the allocator must satisfy the request from <code>ZONE_DMA</code>. This flag is used by device drivers, which need DMA-able memory for their devices. Normally, you combine this flag with the <code>GFP_ATOMIC</code> or <code>GFP_KERNEL</code> flag.</p>
<p>The majority of the code uses either <code>GFP_KERNEL</code> or <code>GFP_ATOMIC</code>. Regardless of the allocation type, you must check for and handle failures.</p>
<p>Below is a list of the common situations and the flags to use.</p>
<table>
<thead>
<tr>
<th>Situation</th>
<th>Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>Process context, can sleep</td>
<td>Use <code>GFP_KERNEL</code>.</td>
</tr>
<tr>
<td>Process context, cannot sleep</td>
<td>Use <code>GFP_ATOMIC</code>, or perform your allocations with <code>GFP_KERNEL</code> at an earlier or later point when you can sleep.</td>
</tr>
<tr>
<td>Interrupt handler</td>
<td>Use <code>GFP_ATOMIC</code>.</td>
</tr>
<tr>
<td>Softirq</td>
<td>Use <code>GFP_ATOMIC</code>.</td>
</tr>
<tr>
<td>Tasklet</td>
<td>Use <code>GFP_ATOMIC</code>.</td>
</tr>
<tr>
<td>Need DMA-able memory, can sleep</td>
<td>Use <code>(GFP_DMA  &#124; GFP_KERNEL)</code>.</td>
</tr>
<tr>
<td>Need DMA-able memory, cannot sleep</td>
<td>Use <code>(GFP_DMA &#124; GFP_ATOMIC)</code>, or perform your allocation at an earlier point when you can sleep.</td>
</tr>
</tbody>
</table>
<h4 id="kfree"><code>kfree()</code></h4>
<p>The counterpart to <code>kmalloc()</code> is <code>kfree()</code>, declared in <code>&lt;linux/slab.h&gt;</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab.h#L144">include/linux/slab.h#L144</a></small></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">kfree</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
</pre></div>


<p>The <code>kfree()</code> method frees a block of memory previously allocated with <code>kmalloc()</code>.</p>
<p>Do not call this function on memory not previously allocated with <code>kmalloc(</code>), or on memory that has already been freed. Doing so is a bug, resulting in bad behavior such as freeing memory belonging to another part of the kernel.</p>
<p>As in user-space, be careful to balance your allocations with your deallocations to prevent memory leaks and other bugs.  <code>kfree(NULL)</code> is explicitly checked for and safe.</p>
<p>[p243]</p>
<h3 id="vmalloc"><code>vmalloc()</code></h3>
<p>The <code>vmalloc()</code> function works in a similar fashion to <code>kmalloc()</code>, except <code>vmalloc()</code> allocates memory that is only virtually contiguous and not necessarily physically contiguous. This is similar to user-space <code>malloc()</code>, the returned pages by which are contiguous within the virtual address space, but necessarily contiguous in physical RAM.</p>
<p>The <code>vmalloc()</code> function ensures that the pages are physically contiguous by by allocating potentially noncontiguous chunks of physical memory and "fixing up" the page tables to map the memory into a contiguous chunk of the logical address space.</p>
<ul>
<li>Usually, only hardware devices require physically contiguous memory allocations, because they live on the other side of the memory management unit and do not understand virtual addresses.</li>
<li>Blocks of memory used only by software (e.g.process-related buffers) are fine using memory that is only virtually contiguous. In your programming, you never know the difference. All memory appears to the kernel as logically contiguous.</li>
</ul>
<p>Though physically contiguous memory is required in only certain cases, most kernel code uses <code>kmalloc()</code> and not <code>vmalloc()</code> to obtain memory primarily for performance. The <code>vmalloc()</code> function, to make nonphysically contiguous pages contiguous in the virtual address space, must specifically set up the page table entries. Worse, pages obtained via <code>vmalloc()</code> must be mapped by their individual pages (because they are not physically contiguous), which results in much greater <a href="https://en.wikipedia.org/wiki/Thrashing_(computer_science)#TLB_thrashing">TLB thrashing</a> than you see when directly mapped memory is used.  Because of these concerns, <code>vmalloc()</code> is used only when absolutely necessary (typically, to obtain large regions of memory). For example, when modules are dynamically inserted into the kernel, they are loaded into memory created via <code>vmalloc()</code>.</p>
<p>The <code>vmalloc()</code> function is declared in <code>&lt;linux/vmalloc.h&gt;</code> and defined in <a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/vmalloc.c#L1595">mm/vmalloc.c</a>. Its usage is identical to user-space’s <code>malloc()</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/vmalloc.h#L53">include/linux/vmalloc.h#L53</a></small></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span> <span class="n">vmalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
</pre></div>


<ul>
<li>The function returns a pointer to at least <code>size</code> bytes of virtually contiguous memory.</li>
<li>On error, the function returns <code>NULL</code>.</li>
<li>The function might sleep and thus cannot be called from interrupt context or other situations in which blocking is not permissible.</li>
</ul>
<p>To free an allocation obtained via <code>vmalloc()</code>, use:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/vmalloc.h#L62">include/linux/vmalloc.h#L62</a></small></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">vfree</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
</pre></div>


<ul>
<li>This function frees the block of memory beginning at <code>addr</code> that was previously allocated via <code>vmalloc()</code>.</li>
<li>The function can sleep and thus cannot be called from interrupt context.</li>
<li>It has no return value</li>
</ul>
<p>[p245]</p>
<h3 id="slab-layer">Slab Layer</h3>
<h4 id="free-lists">Free Lists *</h4>
<p>To facilitate frequent allocations and deallocations of data, programmers often introduce <strong>free lists</strong>. A free list contains a block of available, already allocated, data structures:</p>
<ul>
<li>When code requires a new instance of a data structure, it can grab one of the structures off the free list rather than allocate the sufficient amount of memory and set it up for the data structure.</li>
<li>When the data structure is no longer needed, it is returned to the free list instead of deallocated.</li>
</ul>
<p>In this sense, the free list acts as an object cache, caching a frequently used type of object.</p>
<p>A main problem with free lists in the kernel is that there exists no global control. When available memory is low, there is no way for the kernel to communicate to every free list that it should shrink the sizes of its cache to free up memory. The kernel has no understanding of the random free lists at all.To remedy this and to consolidate code, the Linux kernel provides the <strong>slab layer</strong> (also called the <strong>slab allocator</strong>). The slab layer acts as a generic data structure-caching layer.</p>
<h4 id="slab-layer-generic-data-structure-caching-layer">Slab Layer: generic data structure-caching layer *</h4>
<p>The concept of a slab allocator was first implemented in Sun Microsystem’s SunOS 5.4 operating system. The Linux data structure caching layer shares the same name and basic design.</p>
<p>The slab layer attempts to leverage several basic tenets:</p>
<ul>
<li>Frequently used data structures tend to be allocated and freed often, so cache them.</li>
<li>Frequent allocation and deallocation can result in memory fragmentation (the inability to find large contiguous chunks of available memory).To prevent this, the cached free lists are arranged contiguously. Because freed data structures return to the free list, there is no resulting fragmentation.</li>
<li>The free list provides improved performance during frequent allocation and deallocation because a freed object can be immediately returned to the next allocation.</li>
<li>If the allocator is aware of concepts such as object size, page size, and total cache size, it can make more intelligent decisions.</li>
<li>If part of the cache is made per-processor (separate and unique to each processor on the system), allocations and frees can be performed without an SMP lock.</li>
<li>If the allocator is NUMA-aware, it can fulfill allocations from the same memory node as the requestor.</li>
<li>Stored objects can be colored to prevent multiple objects from mapping to the same cache lines.</li>
</ul>
<p>The slab layer in Linux was designed and implemented with these premises in mind.</p>
<h4 id="design-of-the-slab-layer">Design of the Slab Layer</h4>
<ul>
<li><strong>Caches</strong>. The slab layer divides different objects into groups called caches, each of which stores a different type of object. <u>There is one cache per object type.</u><ul>
<li>For example, one cache is for process descriptors (a free list of <code>task_struct</code> structures), whereas another cache is for inode objects (<code>struct inode</code>).</li>
<li>The <code>kmalloc()</code> interface is built on top of the slab layer, using a family of general purpose caches.</li>
</ul>
</li>
<li><strong>Slabs</strong>. The caches are divided into slabs.The slabs are composed of one or more physically contiguous pages.<ul>
<li>Slabs are typically composed of only a single page.</li>
<li>Each cache may consist of multiple slabs.</li>
</ul>
</li>
<li><strong>Objects</strong>. Each slab contains some number of objects, which are the data structures being cached.<ul>
<li>Each slab is in one of three states: full, partial, or empty:<ul>
<li>A <strong>full slab</strong> has no free objects. (All objects in the slab are allocated.)</li>
<li>An <strong>empty slab</strong> has no allocated objects. (All objects in the slab are free.)</li>
<li>A <strong>partial slab</strong> has some allocated objects and some free objects.</li>
</ul>
</li>
<li>
<p>When some part of the kernel requests a new object:</p>
<ol>
<li>The request is satisfied from a partial slab, if one exists.</li>
<li>Otherwise, the request is satisfied from an empty slab.</li>
<li>If there exists no empty slab, one is created.</li>
</ol>
<p>Obviously, a full slab can never satisfy a request because it does not have any free objects. This strategy reduces fragmentation.</p>
</li>
</ul>
</li>
</ul>
<p>The following figure diagrams the relationship between caches, slabs, and objects.</p>
<p><a href="../figure_12.1.png" title="Figure 12.1 The relationship between caches, slabs, and objects."><img alt="Figure 12.1 The relationship between caches, slabs, and objects." src="../figure_12.1.png" /></a></p>
<p>For example of the <code>inode</code> structure, the in-memory representation of a disk inode (<a href="../ch13/">Chapter 13</a>). These structures are frequently created and destroyed, so it makes sense to manage them via the slab allocator.</p>
<ul>
<li><code>struct inode</code> is allocated from the <code>inode_cachep</code> cache (such a naming convention is standard.). This cache is made up of a lot of slabs because there are a lot of objects and each slab contains as many <code>struct inode</code> objects as possible.</li>
<li>
<p>When the kernel requests a new <code>inode</code> structure, the kernel returns a pointer to:</p>
<ul>
<li>An already allocated but unused structure from a partial slab, or,</li>
<li>An empty slab, if there is no partial slab</li>
</ul>
<p>When the kernel is done using the <code>inode</code> object, the slab allocator marks the object as free.</p>
</li>
</ul>
<p>Each cache is represented by a <code>kmem_cache</code> structure, which contains three lists (stored inside a <code>kmem_list3</code> structure, which is defined in <a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/slab.c#L293">mm/slab.c</a>)</p>
<ul>
<li><code>slabs_full</code></li>
<li><code>slabs_partial</code></li>
<li><code>slabs_empty</code></li>
</ul>
<p>These lists contain all the slabs associated with the cache.</p>
<p>A slab descriptor <code>struct slab</code> represents each slab:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">slab</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span> <span class="cm">/* full, partial, or empty list */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">colouroff</span><span class="p">;</span> <span class="cm">/* offset for the slab coloring */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">s_mem</span><span class="p">;</span> <span class="cm">/* first object in the slab */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inuse</span><span class="p">;</span> <span class="cm">/* allocated objects in the slab */</span>
    <span class="n">kmem_bufctl_t</span> <span class="n">free</span><span class="p">;</span> <span class="cm">/* first free object, if any */</span>
<span class="p">};</span>
</pre></div>


<p>Slab descriptors are allocated either outside the slab in a general cache or inside the slab itself, at the beginning. The descriptor is stored inside the slab if the total size of the slab is sufficiently small, or if internal slack space is sufficient to hold the descriptor.</p>
<p>The slab allocator creates new slabs by interfacing with the low-level kernel page allocator via <code>__get_free_pages()</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/slab.c#L1609">mm/slab.c#L1609</a></small></p>
<div class="codehilite"><pre><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_getpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">flags</span> <span class="o">|=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nodeid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">nodeid</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span>
        <span class="n">atomic_add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_reclaim_pages</span><span class="p">);</span>
    <span class="n">add_page_state</span><span class="p">(</span><span class="n">nr_slab</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SetPageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
      <span class="n">page</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This function uses <code>__get_free_pages()</code> to allocate memory sufficient to hold the
cache:</p>
<ul>
<li>The first parameter <code>cachep</code> points to the specific cache that needs more pages.</li>
<li>The second parameter <code>flags</code> points to the flags given to <code>__get_free_pages()</code>. It adds default flags that the cache requires to the <code>flags</code> parameter.</li>
<li>The third parameter <code>nodeid</code> makes the allocator <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a>-aware. When <code>nodeid</code> is not negative one, the allocator attempts to fulfill the allocation from the same memory node that requested the allocation. This provides better performance on NUMA systems, in which accessing memory outside your node results in a performance penalty.</li>
</ul>
<p>A simplified version <code>kmem_getpages()</code> that ignores NUMA-aware code (for educational purpose) is like:</p>
<div class="codehilite"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">kmem_getpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
    <span class="n">flags</span> <span class="o">|=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Memory is freed by <code>kmem_freepages()</code>, which calls <code>free_pages()</code> on the given cache’s pages.</p>
<p>The point of the slab layer is to refrain from allocating and freeing pages. In turn, the slab layer invokes the page allocation function only when there does not exist any partial or empty slabs in a given cache.The freeing function is called only when available memory grows low and the system is attempting to free memory, or when a cache is explicitly destroyed.</p>
<p>The slab layer is managed on a per-cache basis through a simple interface, which is exported to the entire kernel. The interface enables the creation and destruction of new caches and the allocation and freeing of objects within the caches. The sophisticated management of caches and the slabs within is entirely handled by the internals of the slab layer. After you create a cache, the slab layer works just like a specialized allocator for the specific type of object.</p>
<h4 id="slab-allocator-interface">Slab Allocator Interface</h4>
<p>A new cache is created via <code>kmem_cache_create()</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/slab.c#L2098">/mm/slab.c#L2098</a></small></p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span> <span class="nf">kmem_cache_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span>
                                      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
                                      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</pre></div>


<ul>
<li>The first parameter <code>name</code> is a string storing the name of the cache.</li>
<li>The second parameter <code>size</code> is the size of each element in the cache.</li>
<li>The third parameter <code>align</code> is the offset of the first object within a slab, which ensures a particular alignment within the page. A value of zero results in the standard alignment.</li>
<li>The <code>flags</code> parameter specifies optional settings controlling the cache’s behavior. It can be zero, specifying no special behavior, or one or more of the following flags OR’ed together:<ul>
<li><code>SLAB_HWCACHE_ALIGN</code> instructs the slab layer to align each object within a slab to a cache line, which prevents "false sharing" (two or more objects mapping to the same cache line despite existing at different addresses in memory).<ul>
<li>This improves performance but comes at a cost of increased <a href="https://en.wikipedia.org/wiki/Memory_footprint">memory footprint</a> because the stricter alignment results in more wasted slack space.</li>
<li>How large the increase in memory consumption is depends on the size of the objects and how they naturally align with respect to the system’s cache lines. For frequently used caches in performance-critical code, setting this option is a good idea.</li>
</ul>
</li>
<li><code>SLAB_POISON</code> causes the slab layer to fill the slab with a known value (<em>a5a5a5a5</em>). This is called <strong>poisoning</strong> and is useful for catching access to uninitialized memory.</li>
<li><code>SLAB_RED_ZONE</code> causes the slab layer to insert "red zones" around the allocated memory to help detect buffer overruns.</li>
<li><code>SLAB_PANIC</code> causes the slab layer to panic if the allocation fails. This flag is useful when the allocation must not fail, e.g. allocating the VMA structure cache (<a href="../ch15/">Chapter 15</a>) during bootup.</li>
<li><code>SLAB_CACHE_DMA</code> instructs the slab layer to allocate each slab in DMA-able memory. This is needed if the allocated object is used for DMA and must
reside in <code>ZONE_DMA</code>; otherwise do not set it.</li>
</ul>
</li>
<li>The final parameter <code>ctor</code> is a constructor for the cache. The constructor is called whenever new pages are added to the cache. In practice, caches in the Linux kernel do not often utilize a constructor.</li>
</ul>
<p><code>kmem_cache_destroy</code> destroy a cache:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/slab.c#L2543">mm/slab.c#L2543</a></small></p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
</pre></div>


<p>This function is invoked from module shutdown code in modules that create their own caches. It must not be called from interrupt context because it may sleep.The caller of this function must ensure two conditions before invoking this function:</p>
<ul>
<li>All slabs in the cache are empty. Indeed, if an object in one of the slabs were still allocated and in use, how could the cache be destroyed?</li>
<li>No one accesses the cache during and after a call to <code>kmem_cache_destroy()</code>. The caller must ensure this synchronization</li>
</ul>
<h5 id="allocating-from-the-cache"><strong>Allocating from the Cache</strong></h5>
<p>[p250]</p>
<h4 id="example-of-using-the-slab-allocator"><strong>Example of Using the Slab Allocator</strong></h4>
<p>[p251]</p>
<h3 id="statically-allocating-on-the-stack">Statically Allocating on the Stack</h3>
<p>User-space can afforded large, dynamically growing stack, whereas the the kernel’s stack is small and fixed.</p>
<p>The size of the per-process kernel stacks depends on both the architecture and a compile-time
option. Historically, the kernel stack has been two pages per process.This is usually:</p>
<ul>
<li>8KB for 32-bit architectures (with 4KB pages)</li>
<li>16KB for 64-bit architectures (wtih 8KB pages)</li>
</ul>
<h4 id="single-page-kernel-stacks">Single-Page Kernel Stacks</h4>
<p>Early in the 2.6 kernel series, an option was introduced to move to single-page kernel stacks, where each process is given only a single page (4KB on 32-bit architectures and 8KB on 64-bit architectures). This was done for two reasons:</p>
<ol>
<li>It results in a page with less memory consumption per process.</li>
<li>As uptime increases, it becomes increasingly hard to find two physically contiguous unallocated pages. Physical memory becomes fragmented, and the resulting VM pressure from allocating a single new process is expensive.</li>
</ol>
<p>There is one more complication. <u>Each process’s entire call chain has to fit in its kernel stack.</u> Historically, however, interrupt handlers also used the kernel stack of the process they interrupted, thus they too had to fit. This was efficient and simple, but it placed even tighter constraints on the already meager kernel stack. When the stack moved to only a single page, interrupt handlers no longer fit.</p>
<h5 id="interrupt-stacks"><strong>Interrupt stacks</strong></h5>
<p>To rectify this problem, the kernel developers implemented a new feature: interrupt stacks. <u>Interrupt stacks provide a single per-processor stack used for interrupt handlers. With this option, interrupt handlers no longer share the kernel stack of the interrupted process. </u> Instead, they use their own stacks. This consumes only a single page per processor.</p>
<p>To summarize, kernel stacks are either one or two pages, depending on compile-time configuration options. The stack can therefore range from 4KB to 16KB. Historically, interrupt handlers shared the stack of the interrupted process. When single page stacks are enabled, interrupt handlers are given their own stacks. In any case, unbounded recursion and <code>alloca()</code> are obviously not allowed.</p>
<h4 id="playing-fair-on-the-stack">Playing Fair on the Stack</h4>
<p>In any given function, you must keep stack usage to a minimum. You should keep the sum of all local (automatic) variables in a function to a maximum of a couple hundred bytes. Performing a large static allocation on the stack (e.g. a large array or structure) is dangerous. Otherwise, stack allocations are performed in the kernel just as in user-space.</p>
<p>Stack overflows occur silently and will
undoubtedly result in problems. Because the kernel does not make any effort to manage
the stack, when the stack overflows, the excess data simply spills into whatever exists at
the tail end of the stack, the first thing of which is the <code>thread_info</code> structure, which is allocated at the end of each process’s kernel stack (<a href="../ch3/">Chapter 3</a>).</p>
<p>Beyond the stack, any kernel data might lurk.At best, the machine will crash when the stack overflows. At worst, the overflow will silently corrupt data. Therefore, it is wise to use a dynamic allocation scheme (discussed perviouly in this chapter) for any large memory allocations.</p>
<h3 id="high-memory-mappings">High Memory Mappings</h3>
<p>By definition, pages in high memory might not be permanently mapped into the kernel’s (virtual) address space. Thus, pages obtained via <code>alloc_pages()</code> with the <code>__GFP_HIGHMEM</code> flag might not have a logical address (see relevant text in <a href="#zone-modifiers">Zone Modifers</a> subsection).</p>
<p>On the x86 architecture, all physical memory beyond the 896MB mark is high memory and is not permanently or automatically mapped into the kernel’s address space, despite x86 processors being capable of physically addressing up to 4GB (64GB with <a href="https://en.wikipedia.org/wiki/Physical_Address_Extension">PAE</a>) of physical RAM. After they are allocated, these pages must be mapped into the kernel’s logical address space. On x86, pages in high memory are mapped somewhere between the 3GB and 4GB mark.</p>
<h4 id="permanent-mappings">Permanent Mappings</h4>
<p>To map a given page structure into the kernel’s address space, use this function, declared in <code>&lt;linux/highmem.h&gt;</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/highmem.h#L58">include/linux/highmem.h#L58</a></small></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">kmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
</pre></div>


<p>This function works on either high or low memory:</p>
<ul>
<li>If the <code>page</code> structure belongs to a page in low memory, the page’s virtual address is simply returned.</li>
<li>If the page resides in high memory, a permanent mapping is created and the address is returned.</li>
</ul>
<p>The function may sleep, so <code>kmap()</code> works only in process context.</p>
<p>Because the number of permanent mappings are limited, high memory should be unmapped when no longer needed. This is done via the <code>kunmap</code> function, which unmaps the given page:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">kunmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
</pre></div>


<h4 id="temporary-mappings">Temporary Mappings</h4>
<p>When a mapping must be created but the current context cannot sleep, the kernel provides <strong>temporary mappings</strong> (also called <strong>atomic mappings</strong>). The kernel can atomically map a high memory page into one of the reserved mappings (which can hold temporary mappings). Consequently, a temporary mapping can be used in places that cannot sleep, such as interrupt handlers, because obtaining the mapping never blocks.</p>
<p>Setting up a temporary mapping is done via <code>kmap_atomic()</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/highmem.h#L68">include/linux/highmem.h#L68</a></small></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">kmap_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">km_type</span> <span class="n">type</span><span class="p">)</span>
</pre></div>


<ul>
<li>The <code>type</code> parameter is one of the following enumerations defined in <code>&lt;asm-generic/kmap_types.h&gt;</code>, which describe the purpose of the temporary mapping.</li>
</ul>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/asm-generic/kmap_types.h">include/asm-generic/kmap_types.h</a></small></p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">km_type</span> <span class="p">{</span>
    <span class="n">KM_BOUNCE_READ</span><span class="p">,</span>
    <span class="n">KM_SKB_SUNRPC_DATA</span><span class="p">,</span>
    <span class="n">KM_SKB_DATA_SOFTIRQ</span><span class="p">,</span>
    <span class="n">KM_USER0</span><span class="p">,</span>
    <span class="n">KM_USER1</span><span class="p">,</span>
    <span class="n">KM_BIO_SRC_IRQ</span><span class="p">,</span>
    <span class="n">KM_BIO_DST_IRQ</span><span class="p">,</span>
    <span class="n">KM_PTE0</span><span class="p">,</span>
    <span class="n">KM_PTE1</span><span class="p">,</span>
    <span class="n">KM_PTE2</span><span class="p">,</span>
    <span class="n">KM_IRQ0</span><span class="p">,</span>
    <span class="n">KM_IRQ1</span><span class="p">,</span>
    <span class="n">KM_SOFTIRQ0</span><span class="p">,</span>
    <span class="n">KM_SOFTIRQ1</span><span class="p">,</span>
    <span class="n">KM_SYNC_ICACHE</span><span class="p">,</span>
    <span class="n">KM_SYNC_DCACHE</span><span class="p">,</span>
    <span class="n">KM_UML_USERCOPY</span><span class="p">,</span>
    <span class="n">KM_IRQ_PTE</span><span class="p">,</span>
    <span class="n">KM_NMI</span><span class="p">,</span>
    <span class="n">KM_NMI_PTE</span><span class="p">,</span>
    <span class="n">KM_TYPE_NR</span>
<span class="p">};</span>
</pre></div>


<p>This function does not block and thus can be used in interrupt context and other places that cannot reschedule. It also disables kernel preemption, which is needed because the mappings are unique to each processor and a reschedule might change which task is running on which processor.</p>
<p>The mapping is undone via:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">kunmap_atomic</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">kvaddr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">km_type</span> <span class="n">type</span><span class="p">)</span>
</pre></div>


<p>This function also does not block. In many architectures it does not do anything at all except enable kernel preemption, because a temporary mapping is valid only until the next temporary mapping. Thus, the kernel can just "forget about" the <code>kmap_atomic()</code> mapping, and <code>kunmap_atomic()</code> does not need to do anything special. The next atomic mapping then simply overwrites the previous one.</p>
<h3 id="per-cpu-allocations">Per-CPU Allocations</h3>
<p>Modern SMP-capable operating systems use per-CPU data (data that is unique to a given processor). Typically, per-CPU data is stored in an array. Each item in the array corresponds to a possible processor on the system. The current processor number indexes this array (from 2.4 to 2.6 kernel). [p255] You declare the data as:</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">my_percpu</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
</pre></div>


<p>Then you can access it as:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span> <span class="cm">/* get current processor and disable kernel preemption */</span>
<span class="n">my_percpu</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* ... or whatever */</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;my_percpu on cpu=%d is %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">my_percpu</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
<span class="n">put_cpu</span><span class="p">();</span> <span class="cm">/* enable kernel preemption */</span>
</pre></div>


<p>No lock is required because this data is unique to the current processor. If no processor touches this data except the current, no concurrency concerns exist, and the current processor can safely access the data without lock.</p>
<p>Kernel preemption is the only concern with per-CPU data, which poses two problems:</p>
<ul>
<li>If your code is preempted and reschedules on another processor, the <code>cpu</code> variable is no longer valid because it points to the wrong processor. (In general, code cannot sleep after obtaining the current processor.)</li>
<li>If another task preempts your code, it can concurrently access <code>my_percpu</code> on the same processor, which is a race condition.</li>
</ul>
<p>The call <code>get_cpu()</code>, on top of returning the current processor number, also disables kernel preemption. The corresponding call to <code>put_cpu()</code> enables kernel preemption. If you use a call to <code>smp_processor_id()</code> to get the current processor number, kernel preemption is not disabled. Always use the aforementioned methods to remain safe.</p>
<h3 id="the-new-percpu-interface">The New <code>percpu</code> Interface</h3>
<p>The 2.6 kernel introduced a new interface, <code>percpu</code>, for creating and manipulating per-CPU data. This interface generalizes the previous example. Creation and manipulation of per-CPU data is simplified with this new approach.</p>
<p>The previously discussed method of creating and accessing per-CPU data is still valid and accepted. This new interface, however, grew out of the needs for a simpler and more powerful method for manipulating per-CPU data on large symmetrical multiprocessing computers.</p>
<p>The header <code>&lt;linux/percpu.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/percpu.h">include/linux/percpu.h</a>) declares all the routines. You can find the actual definitions there, in <a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/slab.c">mm/slab.c</a>, and in <code>&lt;asm/percpu.h&gt;</code>.</p>
<h4 id="per-cpu-data-at-compile-time">Per-CPU Data at Compile-Time</h4>
<p>Define a per-CPU variable at compile time:</p>
<div class="codehilite"><pre><span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</pre></div>


<p>This creates an instance of a variable of type <code>type</code>, named <code>name</code>, for each processor on the system. If you need a declaration of the variable elsewhere, to avoid compile warnings, use the following macro:</p>
<div class="codehilite"><pre><span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</pre></div>


<p>You can manipulate the variables with the <code>get_cpu_var()</code> and <code>put_cpu_var()</code> routines. A call to <code>get_cpu_var()</code> returns an lvalue for the given variable on the current processor. It also disables preemption, which <code>put_cpu_var()</code> correspondingly enables.</p>
<div class="codehilite"><pre><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* increment name on this processor */</span>
<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="cm">/* done; enable kernel preemption */</span>
</pre></div>


<p>You can obtain the value of another processor’s per-CPU data, too:</p>
<div class="codehilite"><pre><span class="n">per_cpu</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* increment name on the given processor */</span>
</pre></div>


<p>You need to be careful with this approach because <code>per_cpu()</code> neither disables kernel preemption nor provides any sort of locking mechanism.The lockless nature of per-CPU data exists only if the current processor is the only manipulator of the data. If other processors touch other processors’ data, you need locks. <a href="../ch9/">Chapter 9</a> and <a href="../ch10/">Chapter 10</a> discuss locking.</p>
<p>These compile-time per-CPU examples do not work for modules because the linker actually creates them in a unique executable section (<code>.data.percpu</code>). If you need to access per-CPU data from modules, or if you need to create such data dynamically, you cannot use compile-time per-CPU data.</p>
<h4 id="per-cpu-data-at-runtime">Per-CPU Data at Runtime</h4>
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<p>p235 on zones:</p>
<blockquote>
<p>A specific lock does not protect individual pages, although parts of the kernel may lock the data that happens to reside in said pages.</p>
</blockquote>
<p>p244 on <code>vmalloc()</code>:</p>
<blockquote>
<p>The <code>vmalloc()</code> function, to make nonphysically contiguous pages contiguous in the virtual address space, must specifically set up the page table entries. Worse, pages obtained via <code>vmalloc()</code> must be mapped by their individual pages (because they are not physically contiguous), which results in much greater <a href="https://en.wikipedia.org/wiki/Thrashing_(computer_science)#TLB_thrashing">TLB thrashing</a> than you see when directly mapped memory is used.</p>
</blockquote>
<p>p248 on slab descriptors:</p>
<blockquote>
<p>The descriptor is stored inside the slab if the total size of the slab is sufficiently small, or if internal slack space is sufficient to hold the descriptor.</p>
</blockquote>
<p>p249 on <code>kmem_getpages()</code>:</p>
<blockquote>
<p>For educational purposes, we can ignore the NUMA-aware code and write a simple <code>kmem_getpages()</code>:</p>
</blockquote>
<div class="codehilite"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">kmem_getpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
    <span class="n">flags</span> <span class="o">|=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The "educational" code merely wraps around <code>__get_free_pages</code> without any slab related code. WTF?</p>
<p>p250 on flags to <code>kmem_cache_create()</code>:</p>
<blockquote>
<p><code>SLAB_HWCACHE_ALIGN</code> instructs the slab layer to align each object within a slab to a cache line, which prevents "false sharing" (two or more objects mapping to the same cache line despite existing at different addresses in memory). This improves performance but comes at a cost of increased memory footprint because the stricter alignment results in more wasted slack space. How large the increase in memory consumption is depends on the size of the objects and how they naturally align with respect to the system’s cache lines. For frequently used caches in performance-critical code, setting this option is a good idea; otherwise, think twice.</p>
</blockquote>
<p>p253 on single-page kernel stacks</p>
<blockquote>
<p>When single page stacks are enabled, interrupt handlers are given their own stacks. In any case, unbounded recursion and <code>alloca()</code> are obviously not allowed.</p>
</blockquote>
<p>What is unbounded recursion and <code>alloca()</code>?</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>