<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/lkd/ch13/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 13. The Virtual Filesystem - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/lkd/ch13.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-13-the-virtual-filesystem">Chapter 13. The Virtual Filesystem</a></li>
        
    
        <li class="main "><a href="#common-filesystem-interface">Common Filesystem Interface</a></li>
        
    
        <li class="main "><a href="#filesystem-abstraction-layer">Filesystem Abstraction Layer</a></li>
        
    
        <li class="main "><a href="#unix-filesystems">Unix Filesystems</a></li>
        
            <li><a href="#filesystem-and-namespace">Filesystem and namespace *</a></li>
        
            <li><a href="#files-and-directories">Files and directories *</a></li>
        
            <li><a href="#file-metadata-inode-and-superblock">File metadata, inode and superblock *</a></li>
        
    
        <li class="main "><a href="#vfs-objects-and-their-data-structures">VFS Objects and Their Data Structures</a></li>
        
    
        <li class="main "><a href="#the-superblock-object">The Superblock Object</a></li>
        
    
        <li class="main "><a href="#superblock-operations">Superblock Operations</a></li>
        
    
        <li class="main "><a href="#the-inode-object">The Inode Object</a></li>
        
    
        <li class="main "><a href="#inode-operations">Inode Operations</a></li>
        
    
        <li class="main "><a href="#the-dentry-object">The Dentry Object</a></li>
        
            <li><a href="#dentry-state">Dentry State</a></li>
        
            <li><a href="#the-dentry-cache">The Dentry Cache</a></li>
        
    
        <li class="main "><a href="#dentry-operations">Dentry Operations</a></li>
        
    
        <li class="main "><a href="#the-file-object">The File Object</a></li>
        
    
        <li class="main "><a href="#file-operations">File Operations</a></li>
        
    
        <li class="main "><a href="#data-structures-associated-with-filesystems">Data Structures Associated with Filesystems</a></li>
        
    
        <li class="main "><a href="#data-structures-associated-with-a-process">Data Structures Associated with a Process</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-13-the-virtual-filesystem"><strong>Chapter 13. The Virtual Filesystem</strong><a class="headerlink" href="#chapter-13-the-virtual-filesystem" title="Permanent link">&para;</a></h3>
<blockquote>
<p>Although the kernel developers may shun C++ and other explicitly object-oriented languages, thinking in terms of objects is often useful.
<small>Robert Love</small></p>
</blockquote>
<p>The <strong>Virtual Filesystem</strong> (VFS), sometimes called the <strong>Virtual File Switch</strong> is the subsystem of the kernel that implements the file and filesystem-related interfaces to user-space. All filesystems rely on the VFS not only to coexist but also to interoperate. This enables programs to use standard Unix system calls to read and write to different filesystems, even on different media.</p>
<h3 id="common-filesystem-interface">Common Filesystem Interface<a class="headerlink" href="#common-filesystem-interface" title="Permanent link">&para;</a></h3>
<p>The VFS is the glue that enables system calls such as <code>open()</code>, <code>read()</code>, and <code>write()</code> to work regardless of the filesystem or underlying physical medium. The system calls work between these different filesystems and media; we can use standard system calls to copy or move files from one filesystem to another. Modern operating systems, such as Linux, abstract access to the filesystems via a virtual interface that such interoperation and generic access is possible. [p262]</p>
<p>New filesystems and new varieties of storage media can find their way into Linux, and programs need not be rewritten or even recompiled.</p>
<p>The VFS and the block I/O layer (<a href="../ch14/">Chapter 14</a>) provide the abstractions, interfaces, and glue that allow user-space programs to issue generic system calls to access files via a uniform naming policy on any filesystem, which itself exists on any storage medium.</p>
<h3 id="filesystem-abstraction-layer">Filesystem Abstraction Layer<a class="headerlink" href="#filesystem-abstraction-layer" title="Permanent link">&para;</a></h3>
<p>Such a generic interface for any type of filesystem is feasible only because the kernel implements an abstraction layer around its low-level filesystem interface. This abstraction layer enables Linux to support different filesystems, even if they differ in supported features or behavior.</p>
<p>This is possible because the VFS provides a common file model that can represent any filesystem’s general feature set and behavior. It is biased toward Unix-style filesystems. Regardless, wildly differing filesystem types are still supportable in Linux, from DOS’s FAT to Windows’s NTFS to many Unix-style and Linux-specific filesystems.</p>
<p>The abstraction layer works by defining the basic conceptual interfaces and data structures that all filesystems support. The actual filesystem code hides the implementation details. To the VFS layer and the rest of the kernel, each filesystem looks the same. They all support notions such as files and directories, and they all support operations such as creating and deleting files.</p>
<p>The result is a general abstraction layer that enables the kernel to support many types of filesystems easily and cleanly.The filesystems are programmed to provide the abstracted interfaces and data structures the VFS expects; in turn, the kernel easily works with any filesystem and the exported user-space interface seamlessly works on any filesystem.</p>
<p>Nothing in the kernel needs to understand the underlying details of the filesystems, except the filesystems themselves. For example, consider a simple user-space program that does:</p>
<div class="codehilite"><pre><span class="n">ret</span> <span class="o">=</span> <span class="n">write</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</pre></div>


<p>This system call writes the <code>len</code> bytes pointed to by <code>buf</code> into the current position in the file represented by the file descriptor <code>fd</code>.</p>
<ol>
<li>This system call is first handled by a generic <code>sys_write()</code> system call that determines the actual file writing method for the filesystem
on which <code>fd</code> resides.</li>
<li>The generic write system call then invokes this method, which is part
of the filesystem implementation, to write the data to the media (or whatever this filesystem
does on write).</li>
</ol>
<p>The following figure shows the flow from user-space’s <code>write()</code> call through the data arriving on the physical media. On one side of the system call is the generic VFS interface, providing the frontend to user-space; on the other side of the system call is the filesystem-specific backend, dealing with the implementation details.</p>
<p><a href="../figure_13.2.png" title="Figure 13.2 The flow of data from user-space issuing a write() call, through the VFS’s generic system call, into the filesystem’s specific write method, and finally arriving at the physical media."><img alt="Figure 13.2 The flow of data from user-space issuing a write() call, through the VFS’s generic system call, into the filesystem’s specific write method, and finally arriving at the physical media." src="../figure_13.2_600.png" /></a></p>
<h3 id="unix-filesystems">Unix Filesystems<a class="headerlink" href="#unix-filesystems" title="Permanent link">&para;</a></h3>
<p>Historically, Unix has provided four basic filesystem-related abstractions:</p>
<ul>
<li>Files</li>
<li>Directory entries</li>
<li>inodes</li>
<li>Mount points</li>
</ul>
<h4 id="filesystem-and-namespace">Filesystem and namespace *<a class="headerlink" href="#filesystem-and-namespace" title="Permanent link">&para;</a></h4>
<p>A <strong>filesystem</strong> is a hierarchical storage of data adhering to a specific structure. Filesystems contain files, directories, and associated control information. Typical operations performed on filesystems are creation, deletion, and mounting. In Unix, filesystems are mounted at a specific mount point in a global hierarchy known as a <strong>namespace</strong>. (Linux has made this hierarchy per-process, to give a unique namespace to each process.  Because each process inherits its parent’s namespace unless you specify otherwise, there is seemingly one global namespace.) This enables all mounted filesystems to appear as entries in a single tree.</p>
<p>Contrast this single, unified tree with the behavior of DOS and Windows, which break the file namespace up into drive letters, such as <code>C:</code>. This breaks the namespace up among device and partition boundaries, "leaking" hardware details into the filesystem abstraction. As this delineation may be arbitrary and even confusing to the user, it is inferior to Linux’s unified namespace</p>
<h4 id="files-and-directories">Files and directories *<a class="headerlink" href="#files-and-directories" title="Permanent link">&para;</a></h4>
<p>A <strong>file</strong> is an ordered string of bytes. The first byte marks the beginning of the file, and the last byte marks the end of the file. Each file is assigned a human-readable name for identification by both the system and the user. Typical file operations are read, write, create, and delete. The Unix concept of the file is in stark contrast to record-oriented filesystems, such as OpenVMS’s Files-11. <a href="https://en.wikipedia.org/wiki/Record-oriented_filesystem">Record-oriented filesystems</a> provide a richer, more structured representation of files than Unix’s simple byte-stream abstraction, at the cost of simplicity and flexibility.</p>
<p>Files are organized in directories. A <strong>directory</strong> is analogous to a folder and usually contains related files. Directories can also contain other directories, called subdirectories. In this fashion, directories may be nested to form paths. Each component of a path is called a directory entry. A path example is <code>/home/wolfman/butter</code>: the root directory <code>/</code>, the directories <code>home</code> and <code>wolfman</code>, and the file <code>butter</code> are all directory entries, called <strong>dentries</strong>. In Unix, directories are actually normal files that simply list the files contained therein. Because a directory is a file to the VFS, the same operations performed on files can be performed on directories.</p>
<h4 id="file-metadata-inode-and-superblock">File metadata, inode and superblock *<a class="headerlink" href="#file-metadata-inode-and-superblock" title="Permanent link">&para;</a></h4>
<p>Unix systems separate the concept of a file from any associated information about it, such as access permissions, size, owner, creation time, and so on. This information is sometimes called <strong>file metadata</strong> (data about the file’s data) and is stored in a separate data structure from the file, called the <strong>inode</strong>. This name is short for index node, although these days the term inode is much more ubiquitous.</p>
<p>All this information is tied together with the filesystem’s own control information, which is stored in the <strong>superblock</strong>. The superblock is a data structure containing information about the filesystem as a whole. Sometimes the collective data is referred to as <strong>filesystem metadata</strong>. Filesystem metadata includes information about both the individual files and the filesystem as a whole.</p>
<p>Traditionally, Unix filesystems implement these notions as part of their physical on-disk layout. For example, file information is stored as an inode in a separate block on the disk; directories are files; control information is stored centrally in a superblock, and so on. The Unix file concepts are <em>physically mapped</em> on to the storage medium.</p>
<p>The Linux VFS is designed to work with filesystems that understand and implement such concepts. Non-Unix filesystems, such as FAT or NTFS, still work in Linux, but their filesystem code must provide the appearance of these concepts. For example, even if a filesystem does not support distinct inodes, it must assemble the inode data structure in memory as if it did. Or if a filesystem treats directories as a special object, to the VFS they must represent directories as mere files. Often, this involves some special processing done on-the-fly by the non-Unix filesystems to cope with the Unix paradigm and the requirements of the VFS. Such filesystems still work, however, and the overhead is not unreasonable.</p>
<h3 id="vfs-objects-and-their-data-structures">VFS Objects and Their Data Structures<a class="headerlink" href="#vfs-objects-and-their-data-structures" title="Permanent link">&para;</a></h3>
<p>The VFS is object-oriented. A family of data structures represents the common file model. These data structures are akin to objects. Because the kernel is programmed strictly in C, without the benefit of a language directly supporting object-oriented paradigms, the data structures are represented as C structures. The structures contain both data and pointers to filesystem-implemented functions that operate on the data.</p>
<p>The four primary object types of the VFS are:</p>
<ul>
<li>The <strong>superblock</strong> object, which represents a specific mounted filesystem.</li>
<li>The <strong>inode</strong> object, which represents a specific file.</li>
<li>The <strong>dentry</strong> object, which represents a directory entry, which is a single component of a path.</li>
<li>The <strong>file</strong> object, which represents an open file as associated with a process.</li>
</ul>
<p>Because the VFS treats directories as normal files, there is not a specific directory object. A dentry represents a component in a path, which might include a regular file. In other words, a dentry is not the same as a directory, but a directory is just another kind of file.</p>
<p>An <em>operations</em> object is contained within each of these primary objects. These objects describe the methods that the kernel invokes against the primary objects:</p>
<ul>
<li>The <strong><code>super_operations</code></strong> object, which contains the methods that the kernel can invoke on a specific filesystem, such as <code>write_inode()</code> and <code>sync_fs()</code>.</li>
<li>The <strong><code>inode_operations</code></strong> object, which contains the methods that the kernel can invoke on a specific file, such as <code>create()</code> and <code>link()</code>.</li>
<li>The <strong><code>dentry_operations</code></strong> object, which contains the methods that the kernel can invoke on a specific directory entry, such as <code>d_compare()</code> and <code>d_delete()</code>.</li>
<li>The <strong><code>file_operations</code></strong> object, which contains the methods that a process can invoke on an open file, such as <code>read()</code> and <code>write()</code>.</li>
</ul>
<p>The operations objects are implemented as a structure of pointers to functions that operate on the parent object. For many methods, the objects can inherit a generic function if basic functionality is sufficient. Otherwise, the specific instance of the particular filesystem fills in the pointers with its own filesystem-specific methods.</p>
<p>Note that objects refer to structures, not explicit class types, such as those in C++ or Java. These structures, however, represent specific instances of an object, their associated data, and methods to operate on themselves. They are very much objects.</p>
<p>The VFS is comprised of a couple more than the primary objects previously discussed:</p>
<ul>
<li>Each registered filesystem is represented by a <code>file_system_type</code> structure. This object describes the filesystem and its capabilities.</li>
<li>Each mount point is represented by the <code>vfsmount</code> structure. This structure contains information about the mount point, such as its location and mount flags.</li>
</ul>
<p>Two per-process structures, which describe the filesystem and files associated with a process, are respectively, the <code>fs_struct</code> structure and the <code>file</code> structure. The rest of this chapter discusses these objects and the role they play in implementing the VFS layer.</p>
<p>The superblock object is implemented by each filesystem and is used to store information
describing that specific filesystem. This object usually corresponds to the filesystem
superblock or the filesystem control block, which is stored in a special sector on disk (hence
the object’s name). Filesystems that are not disk-based (a virtual memory–based filesystem,
such as sysfs) generate the superblock on-the-fly and store it in memory.</p>
<p>The superblock object is represented by struct <code>super_block</code> and defined in <code>&lt;linux/fs.h&gt;</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/fs.h#L1319">include/linux/fs.h#L1319</a></small></p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">super_block</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_list</span><span class="p">;</span> <span class="cm">/* list of all superblocks */</span>
    <span class="kt">dev_t</span> <span class="n">s_dev</span><span class="p">;</span> <span class="cm">/* identifier */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_blocksize</span><span class="p">;</span> <span class="cm">/* block size in bytes */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">s_blocksize_bits</span><span class="p">;</span> <span class="cm">/* block size in bits */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">s_dirt</span><span class="p">;</span> <span class="cm">/* dirty flag */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">s_maxbytes</span><span class="p">;</span> <span class="cm">/* max file size */</span>
    <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">s_type</span><span class="p">;</span> <span class="cm">/* filesystem type */</span>
    <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">s_op</span><span class="p">;</span> <span class="cm">/* superblock methods */</span>
    <span class="k">struct</span> <span class="n">dquot_operations</span> <span class="o">*</span><span class="n">dq_op</span><span class="p">;</span> <span class="cm">/* quota methods */</span>
    <span class="k">struct</span> <span class="n">quotactl_ops</span> <span class="o">*</span><span class="n">s_qcop</span><span class="p">;</span> <span class="cm">/* quota control methods */</span>
    <span class="k">struct</span> <span class="n">export_operations</span> <span class="o">*</span><span class="n">s_export_op</span><span class="p">;</span> <span class="cm">/* export methods */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_flags</span><span class="p">;</span> <span class="cm">/* mount flags */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_magic</span><span class="p">;</span> <span class="cm">/* filesystem’s magic number */</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">s_root</span><span class="p">;</span> <span class="cm">/* directory mount point */</span>
    <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">s_umount</span><span class="p">;</span> <span class="cm">/* unmount semaphore */</span>
    <span class="k">struct</span> <span class="n">semaphore</span> <span class="n">s_lock</span><span class="p">;</span> <span class="cm">/* superblock semaphore */</span>
    <span class="kt">int</span> <span class="n">s_count</span><span class="p">;</span> <span class="cm">/* superblock ref count */</span>
    <span class="kt">int</span> <span class="n">s_need_sync</span><span class="p">;</span> <span class="cm">/* not-yet-synced flag */</span>
    <span class="n">atomic_t</span> <span class="n">s_active</span><span class="p">;</span> <span class="cm">/* active reference count */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">s_security</span><span class="p">;</span> <span class="cm">/* security module */</span>
    <span class="k">struct</span> <span class="n">xattr_handler</span> <span class="o">**</span><span class="n">s_xattr</span><span class="p">;</span> <span class="cm">/* extended attribute handlers */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_inodes</span><span class="p">;</span> <span class="cm">/* list of inodes */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_dirty</span><span class="p">;</span> <span class="cm">/* list of dirty inodes */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_io</span><span class="p">;</span> <span class="cm">/* list of writebacks */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_more_io</span><span class="p">;</span> <span class="cm">/* list of more writeback */</span>
    <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">s_anon</span><span class="p">;</span> <span class="cm">/* anonymous dentries */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_files</span><span class="p">;</span> <span class="cm">/* list of assigned files */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_dentry_lru</span><span class="p">;</span> <span class="cm">/* list of unused dentries */</span>
    <span class="kt">int</span> <span class="n">s_nr_dentry_unused</span><span class="p">;</span> <span class="cm">/* number of dentries on list */</span>
    <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">s_bdev</span><span class="p">;</span> <span class="cm">/* associated block device */</span>
    <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">s_mtd</span><span class="p">;</span> <span class="cm">/* memory disk information */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_instances</span><span class="p">;</span> <span class="cm">/* instances of this fs */</span>
    <span class="k">struct</span> <span class="n">quota_info</span> <span class="n">s_dquot</span><span class="p">;</span> <span class="cm">/* quota-specific options */</span>
    <span class="kt">int</span> <span class="n">s_frozen</span><span class="p">;</span> <span class="cm">/* frozen status */</span>
    <span class="n">wait_queue_head_t</span> <span class="n">s_wait_unfrozen</span><span class="p">;</span> <span class="cm">/* wait queue on freeze */</span>
    <span class="kt">char</span> <span class="n">s_id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="cm">/* text name */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">s_fs_info</span><span class="p">;</span> <span class="cm">/* filesystem-specific info */</span>
    <span class="n">fmode_t</span> <span class="n">s_mode</span><span class="p">;</span> <span class="cm">/* mount permissions */</span>
    <span class="k">struct</span> <span class="n">semaphore</span> <span class="n">s_vfs_rename_sem</span><span class="p">;</span> <span class="cm">/* rename semaphore */</span>
    <span class="n">u32</span> <span class="n">s_time_gran</span><span class="p">;</span> <span class="cm">/* granularity of timestamps */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s_subtype</span><span class="p">;</span> <span class="cm">/* subtype name */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s_options</span><span class="p">;</span> <span class="cm">/* saved mount options */</span>
<span class="p">};</span>
</pre></div>


<p>The code for creating, managing, and destroying superblock objects lives in <a href="https://github.com/shichao-an/linux/blob/v2.6.34/fs/super.c">fs/super.c</a>. A superblock object is created and initialized via the <code>alloc_super()</code> function. When mounted, a filesystem invokes this function, reads its superblock off of the disk, and fills in its superblock object.</p>
<p>The most important item in the superblock object is <code>s_op</code>, which is a pointer to the superblock operations table. The superblock operations table is represented by <code>struct super_operations</code> and is defined in <code>&lt;linux/fs.h&gt;</code>, which looks like this:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">super_operations</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dirty_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">drop_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">delete_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unfreeze_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clear_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">umount_begin</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show_options</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">quota_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">quota_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bdev_try_to_free_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>Each item in this structure is a pointer to a function that operates on a superblock object. The superblock operations perform low-level operations on the filesystem and its inodes.</p>
<p>When a filesystem needs to perform an operation on its superblock, it follows the pointers from its superblock object to the desired method. For example, if a filesystem wanted to write to its superblock, it would invoke:</p>
<div class="codehilite"><pre><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
</pre></div>


<p>In this call, <code>sb</code> is a pointer to the filesystem’s superblock. Following that pointer into <code>s_op</code> yields the superblock operations table and ultimately the desired <code>write_super()</code> function, which is then invoked. Note how the <code>write_super()</code> call must be passed a superblock, despite the method being associated with one. This is because of the lack of object-oriented support in C. In C++, a call such as the following would suffice:</p>
<div class="codehilite"><pre><span class="n">sb</span><span class="p">.</span><span class="n">write_super</span><span class="p">();</span>
</pre></div>


<p>In C, there is no way for the method to easily obtain its parent, so you have to pass it.</p>
<p>The following are some of the superblock operations that are specified by <code>super_operations</code>:</p>
<ul>
<li><code>struct inode * alloc_inode(struct super_block *sb)</code><ul>
<li>Creates and initializes a new inode object under the given superblock.</li>
</ul>
</li>
<li><code>void destroy_inode(struct inode *inode)</code><ul>
<li>Deallocates the given inode.</li>
</ul>
</li>
<li><code>void dirty_inode(struct inode *inode)</code><ul>
<li>Invoked by the VFS when an inode is dirtied (modified). Journaling filesystems such as ext3 and ext4 use this function to perform journal updates.</li>
</ul>
</li>
<li><code>void write_inode(struct inode *inode, int wait)</code><ul>
<li>Writes the given inode to disk. The <code>wait</code> parameter specifies whether the operation should be synchronous.</li>
</ul>
</li>
<li><code>void drop_inode(struct inode *inode)</code><ul>
<li>Called by the VFS when the last reference to an inode is dropped. Normal Unix filesystems do not define this function, in which case the VFS simply deletes the inode.</li>
</ul>
</li>
<li><code>void delete_inode(struct inode *inode)</code><ul>
<li>Deletes the given inode from the disk.</li>
</ul>
</li>
<li><code>void put_super(struct super_block *sb)</code><ul>
<li>Called by the VFS on unmount to release the given superblock object.The caller must hold the <code>s_lock</code> lock.</li>
</ul>
</li>
<li><code>void write_super(struct super_block *sb)</code><ul>
<li>Updates the on-disk superblock with the specified superblock.The VFS uses this function to synchronize a modified in-memory superblock with the disk. The caller must hold the <code>s_lock</code> lock.</li>
</ul>
</li>
<li><code>int sync_fs(struct super_block *sb, int wait)</code><ul>
<li>Synchronizes filesystem metadata with the on-disk filesystem. The <code>wait</code> parameter specifies whether the operation is synchronous.</li>
</ul>
</li>
<li><code>void write_super_lockfs(struct super_block *sb)</code><ul>
<li>Prevents changes to the filesystem, and then updates the on-disk superblock with the specified superblock. It is currently used by LVM (the Logical Volume Manager).</li>
</ul>
</li>
<li><code>void unlockfs(struct super_block *sb)</code><ul>
<li>Unlocks the filesystem against changes as done by <code>write_super_lockfs()</code>.</li>
</ul>
</li>
<li><code>int statfs(struct super_block *sb, struct statfs *statfs)</code><ul>
<li>Called by the VFS to obtain filesystem statistics. The statistics related to the given filesystem are placed in <code>statfs</code>.</li>
</ul>
</li>
<li><code>int remount_fs(struct super_block *sb, int *flags, char *data)</code><ul>
<li>Called by the VFS when the filesystem is remounted with new mount options.The caller must hold the <code>s_lock</code> lock.</li>
</ul>
</li>
<li><code>void clear_inode(struct inode *inode)</code><ul>
<li>Called by the VFS to release the inode and clear any pages containing related data.</li>
</ul>
</li>
<li><code>void umount_begin(struct super_block *sb)</code><ul>
<li>Called by the VFS to interrupt a mount operation. It is used by network filesystems, such as NFS.</li>
</ul>
</li>
</ul>
<h3 id="the-superblock-object">The Superblock Object<a class="headerlink" href="#the-superblock-object" title="Permanent link">&para;</a></h3>
<h3 id="superblock-operations">Superblock Operations<a class="headerlink" href="#superblock-operations" title="Permanent link">&para;</a></h3>
<h3 id="the-inode-object">The Inode Object<a class="headerlink" href="#the-inode-object" title="Permanent link">&para;</a></h3>
<h3 id="inode-operations">Inode Operations<a class="headerlink" href="#inode-operations" title="Permanent link">&para;</a></h3>
<h3 id="the-dentry-object">The Dentry Object<a class="headerlink" href="#the-dentry-object" title="Permanent link">&para;</a></h3>
<h4 id="dentry-state">Dentry State<a class="headerlink" href="#dentry-state" title="Permanent link">&para;</a></h4>
<h4 id="the-dentry-cache">The Dentry Cache<a class="headerlink" href="#the-dentry-cache" title="Permanent link">&para;</a></h4>
<h3 id="dentry-operations">Dentry Operations<a class="headerlink" href="#dentry-operations" title="Permanent link">&para;</a></h3>
<h3 id="the-file-object">The File Object<a class="headerlink" href="#the-file-object" title="Permanent link">&para;</a></h3>
<h3 id="file-operations">File Operations<a class="headerlink" href="#file-operations" title="Permanent link">&para;</a></h3>
<h3 id="data-structures-associated-with-filesystems">Data Structures Associated with Filesystems<a class="headerlink" href="#data-structures-associated-with-filesystems" title="Permanent link">&para;</a></h3>
<h3 id="data-structures-associated-with-a-process">Data Structures Associated with a Process<a class="headerlink" href="#data-structures-associated-with-a-process" title="Permanent link">&para;</a></h3>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>