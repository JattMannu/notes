<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch6/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 6. Methods - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch6.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-6-methods">Chapter 6. Methods</a></li>
        
    
        <li class="main "><a href="#method-declarations">Method Declarations</a></li>
        
    
        <li class="main "><a href="#methods-with-a-pointer-receiver">Methods with a Pointer Receiver</a></li>
        
            <li><a href="#summary-of-three-cases">Summary of three cases *</a></li>
        
            <li><a href="#nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</a></li>
        
    
        <li class="main "><a href="#composing-types-by-struct-embedding">Composing Types by Struct Embedding</a></li>
        
    
        <li class="main "><a href="#method-values-and-expressions">Method Values and Expressions</a></li>
        
    
        <li class="main "><a href="#example-bit-vector-type">Example: Bit Vector Type</a></li>
        
    
        <li class="main "><a href="#encapsulation">Encapsulation</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-6-methods"><strong>Chapter 6. Methods</strong></h3>
<p>An <em>object</em> is a value or variable that has methods, and a <em>method</em> is a function associated with a particular type. An object-oriented program uses methods to express the properties and operations of each data structure so that clients need not access the object's representation directly.</p>
<p>[p155]</p>
<p>This chapter discusses the following topics on methods:</p>
<ul>
<li>How to define and use methods effectively</li>
<li>Encapsulation</li>
<li>Composition</li>
</ul>
<h3 id="method-declarations">Method Declarations</h3>
<p>A method is declared with a variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attaches the function to the type of that parameter.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/geometry/geometry.go">gopl.io/ch6/geometry/geometry.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">geometry</span>

<span class="kn">import</span> <span class="s">&quot;math&quot;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c1">// traditional function</span>
<span class="kd">func</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// same thing, but as a method of the Point type</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The extra parameter <code>p</code> is called the method's <em>receiver</em>, a legacy from early object-oriented languages that described calling a method as "sending a message to an object".</p>
<p>In Go, the receiver does not have a special name like <code>this</code> or <code>self</code>; it's naming is similar to any other parameter. Since the receiver name will be frequently used, it's a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like <code>p</code> for <code>Point</code>.</p>
<p>In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;, function call</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span>  <span class="c1">// &quot;5&quot;, method call</span>
</pre></div>


<p>There's no conflict between the two declarations of functions called <code>Distance</code> above:</p>
<ul>
<li>The first declares a package-level function called <code>geometry.Distance</code>.</li>
<li>The second declares a method of the type <code>Point</code> called <code>Point.Distance</code>.</li>
</ul>
<p>Since each type has its own name space for methods, we can use the name <code>Distance</code> for other methods as long as they belong to different types. The following example defines a type <code>Path</code> that represents a sequence of line segments and a <code>Distance</code> method:</p>
<div class="codehilite"><pre><span class="c1">// A Path is a journey connecting the points with straight lines.</span>
<span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="c1">// Distance returns the distance traveled along the path.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</pre></div>


<p>Although <code>Path</code> is a named slice type, not a struct type like <code>Point</code>, we can still define methods for it.</p>
<p>Unlike many other object-oriented languages, <u>Go allows methods to be associated with any type, such as numbers, strings, slices, maps, and even functions.</u> Methods may be declared on any named type defined in the same package, so long as its underlying type is neither a pointer nor an interface.</p>
<p>The two <code>Distance</code> methods have different types. They're not related to each other at all, though <code>Path.Distance</code> uses <code>Point.Distance</code> internally to compute the length of each segment that connects adjacent points.</p>
<p>The following code calls the new method to compute the perimeter of a right triangle:</p>
<div class="codehilite"><pre><span class="nx">perim</span> <span class="o">:=</span> <span class="nx">Path</span><span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span> <span class="c1">// &quot;12&quot;</span>
</pre></div>


<p>In the two examples above, there are two calls to methods named <code>Distance</code>. <u>The compiler determines which function to call based on both the method name and the type of the receiver.</u></p>
<ul>
<li>In the first, <code>path[i-1]</code> has type <code>Point</code> so <code>Point.Distance</code> is called.</li>
<li>In the second, <code>perim</code> has type <code>Path</code>, so <code>Path.Distance</code> is called.</li>
</ul>
<p>All methods of a given type must have unique names, but different types can use the same name for a method, like the <code>Distance</code> methods for <code>Point</code> and <code>Path</code>; there's no need to qualify function names (for example, <code>PathDistance</code>) to disambiguate. The first benefit to using methods over ordinary functions is: method names can be shorter. This benefit is magnified for calls originating outside the package, since they can use the shorter name and omit the package name:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="s">&quot;gopl.io/ch6/geometry&quot;</span>
<span class="nx">perim</span> <span class="o">:=</span> <span class="nx">geometry</span><span class="p">.</span><span class="nx">Path</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">PathDistance</span><span class="p">(</span><span class="nx">perim</span><span class="p">))</span> <span class="c1">// &quot;12&quot;, standalone function</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span>             <span class="c1">// &quot;12&quot;, method of geometry.Path</span>
</pre></div>


<h3 id="methods-with-a-pointer-receiver">Methods with a Pointer Receiver</h3>
<p>Calling a function makes a copy of each argument value. If either of the following occurs, we must pass the address of the variable using a pointer:</p>
<ul>
<li>The function needs to update a variable.</li>
<li>An argument is so large that we wish to avoid copying it.</li>
</ul>
<p>The same goes for methods that need to update the receiver variable: we attach them to the pointer type, such as <code>*Point</code>. For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*=</span> <span class="nx">factor</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*=</span> <span class="nx">factor</span>
<span class="p">}</span>
</pre></div>


<p>The name of this method is <code>(*Point).ScaleBy</code>. The parentheses are necessary; without them, the expression would be parsed as <code>*(Point.ScaleBy)</code>.</p>
<p>Convention dictates that if any method of <code>Point</code> has a pointer receiver, then all methods of <code>Point</code> should have a pointer receiver, even ones that don't strictly need it.  We've broken this rule for <code>Point</code> so that we can show both kinds of method.</p>
<p>Named types (<code>Point</code>) and pointers to them (<code>*Point</code>) are the only types that may appear in a
receiver declaration. <u>To avoid ambiguities, method declarations are not permitted on named types that are themselves <code>pointer</code> types</u>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">P</span> <span class="o">*</span><span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">P</span><span class="p">)</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// compile error: invalid receiver type</span>
</pre></div>


<p>The <code>(*Point).ScaleBy</code> method can be called by providing a <code>*Point</code> receiver. The following three cases are equivalent:</p>
<div class="codehilite"><pre><span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">pptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">).</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<p>The last two cases are verbose; <u>if the receiver <code>p</code> is a variable of type <code>Point</code> but the method requires a *Point receiver, the compiler will perform an implicit <code>&amp;p</code> on the variable.</u> So we can use the following shorthand:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>


<p>This works only for variables, including struct fields like <code>p.X</code> and array or slice elements like <code>perim[0]</code>. We cannot call a <code>*Point</code> method on a non-addressable <code>Point</code> receiver, because there's no way to obtain the address of a temporary value. For example:</p>
<div class="codehilite"><pre><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// compile error: can&#39;t take address of Point literal</span>
</pre></div>


<p>However, we can call a <code>Point</code> method (e.g. <code>Point.Distance</code>) with a <code>*Point</code> receiver, because there is a way to obtain the value from the address by loading the value pointed to by the receiver. The compiler will perform an implicit <code>*</code> on the variable. These two function calls are equivalent:</p>
<div class="codehilite"><pre><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="nx">pptr</span><span class="p">).</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
</pre></div>


<h4 id="summary-of-three-cases">Summary of three cases *</h4>
<p>In every valid method call expression, exactly one of these three statements is true.</p>
<p>The receiver argument has the same type as the receiver parameter. For example, both have type <code>T</code> or both have type <code>*T</code>:</p>
<div class="codehilite"><pre><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// Point</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1">// *Point</span>
</pre></div>


<p>The receiver argument is a variable of type <code>T</code> and the receiver parameter has type <code>*T</code>. The compiler implicitly takes the address of the variable. For example:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// implicit (&amp;p)</span>
</pre></div>


<p>The receiver argument has type <code>*T</code> and the receiver parameter has type <code>T</code>. The compiler
implicitly dereferences the receiver, in other words, loads the value. For example:</p>
<div class="codehilite"><pre><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// implicit (*pptr)</span>
</pre></div>


<p>If all the methods of a named type <code>T</code> have a receiver type of <code>T</code> itself (not <code>*T</code>), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. For example, <code>time.Duration</code> values are liberally copied, including as arguments to functions.</p>
<p>But if any method has a pointer receiver, you should avoid copying instances of <code>T</code> because doing so may violate internal invariants. For example, copying an instance of <code>bytes.Buffer</code> would cause the original and the copy to alias (<a href="../ch2/#pointers">Section 2.3.2</a>) the same underlying array of bytes. Subsequent method calls would have unpredictable effects.</p>
<h4 id="nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</h4>
<p>Some methods allow nil pointers as their receivers, especially if <code>nil</code> is a meaningful zero value of the type (e.g. maps and slices), just as some functions allow nil pointers as arguments. For example, <code>nil</code> represents the empty list:</p>
<div class="codehilite"><pre><span class="c1">// An IntList is a linked list of integers.</span>
<span class="c1">// A nil *IntList represents the empty list.</span>
<span class="kd">type</span> <span class="nx">IntList</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Value</span> <span class="kt">int</span>
    <span class="nx">Tail</span> <span class="o">*</span><span class="nx">IntList</span>
<span class="p">}</span>

<span class="c1">// Sum returns the sum of the list elements.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">list</span> <span class="o">*</span><span class="nx">IntList</span><span class="p">)</span> <span class="nx">Sum</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">list</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>When you define a type whose methods allow nil as a receiver value, it's worth documenting this explicitly in the comment, as in the example above.</p>
<p>The following is part of the definition of the Values type from the <a href="https://golang.org/pkg/net/url/"><code>net/url</code></a> package:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">url</span>

<span class="c1">// Values maps a string key to a list of values.</span>
<span class="kd">type</span> <span class="nx">Values</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>

<span class="c1">// Get returns the first value associated with the given key,</span>
<span class="c1">// or &quot;&quot; if there are none.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">vs</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;&quot;</span>
<span class="p">}</span>

<span class="c1">// Add adds the value to key.</span>
<span class="c1">// It appends to any existing values associated with key.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>It exposes its representation as a map but also provides methods to simplify access to the map, whose values are slices of strings; it's a <a href="https://en.wikipedia.org/wiki/Multimap"><em>multimap</em></a>. Its clients can use its intrinsic operators (<code>make</code>, slice literals, <code>m[key]</code>, and so on), or its methods, or both:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/urlvalues/main.go">gopl.io/ch6/urlvalues/main.go</a></small></p>
<div class="codehilite"><pre><span class="nx">m</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">{</span><span class="s">&quot;lang&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;en&quot;</span><span class="p">}}</span> <span class="c1">// direct construction</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;lang&quot;</span><span class="p">))</span> <span class="c1">// &quot;en&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">))</span>    <span class="c1">// &quot;&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;1&quot;      (first value)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;item&quot;</span><span class="p">])</span>     <span class="c1">// &quot;[1 2]&quot;  (direct map access)</span>

<span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;&quot;</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">)</span>         <span class="c1">// panic: assignment to entry in nil map</span>
</pre></div>


<p>In the final call to <code>Get</code>, the nil receiver behaves like an empty map. It is equivalent to being written as <code>Values(nil).Get("item"))</code>, not <code>nil.Get("item")</code>, which will not compile because the type of <code>nil</code> has not been determined (see <a href="https://play.golang.org/p/fW0q7pRRUp">modified version of the example above</a>). By contrast, the final call to <code>Add</code> panics as it tries to update a <code>nil</code> map.</p>
<p>Because <code>url.Values</code> is a map type and a map refers to its key/value pairs indirectly, any updates and deletions that <code>url.Values.Add</code> makes to the map elements are visible to the caller. However, as with ordinary functions, any changes a method makes to the reference itself, like setting it to <code>nil</code> or making it refer to a different map data structure, will not be reflected in the caller.</p>
<h3 id="composing-types-by-struct-embedding">Composing Types by Struct Embedding</h3>
<h3 id="method-values-and-expressions">Method Values and Expressions</h3>
<h3 id="example-bit-vector-type">Example: Bit Vector Type</h3>
<h3 id="encapsulation">Encapsulation</h3>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>