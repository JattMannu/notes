<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch7/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 7. Interfaces - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch7.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-7-interfaces">Chapter 7. Interfaces</a></li>
        
    
        <li class="main "><a href="#interfaces-as-contracts">Interfaces as Contracts</a></li>
        
            <li><a href="#concrete-type-and-interface-type">Concrete type and interface type *</a></li>
        
            <li><a href="#the-iowriter-interface">The io.Writer interface *</a></li>
        
            <li><a href="#the-fmtstringer-interface">The fmt.Stringer interface *</a></li>
        
    
        <li class="main "><a href="#interface-types">Interface Types</a></li>
        
    
        <li class="main "><a href="#interface-satisfaction">Interface Satisfaction</a></li>
        
            <li><a href="#empty-interface-interface">Empty interface: interface{} *</a></li>
        
    
        <li class="main "><a href="#parsing-flags-with-flagvalue">Parsing Flags with flag.Value</a></li>
        
    
        <li class="main "><a href="#interface-values">Interface Values</a></li>
        
    
        <li class="main "><a href="#the-httphandler-interface">The http.Handler Interface</a></li>
        
    
        <li class="main "><a href="#sorting-with-sortinterface">Sorting with sort.Interface</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-7-interfaces"><strong>Chapter 7. Interfaces</strong></h3>
<p>Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces facilitate more flexible and adaptable functions because they are not tied to the details of one particular implementation.</p>
<p>Different from the notion of interfaces in other object-oriented languages, Go's interfaces is distinctive in that they are satisfied implicitly. In other words, there's no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. With this design, you are able to create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don't control.</p>
<p>This chapter discusses:</p>
<ul>
<li>Basic mechanics of interface types and their values</li>
<li>Several important interfaces from the standard library</li>
<li>Type assertions and type switches</li>
</ul>
<h3 id="interfaces-as-contracts">Interfaces as Contracts</h3>
<h4 id="concrete-type-and-interface-type">Concrete type and interface type *</h4>
<p>All the types discussed so far are <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)#Abstract_and_Concrete"><strong>concrete types</strong></a>. A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetic for numbers, or indexing, <code>append</code>, and <code>range</code> for slices. A concrete type may also provide additional behaviors through its methods. When you have a value of a concrete type, you know exactly what it is and what you can do with it.</p>
<p>There is another kind of type in Go called an <strong>interface type</strong>. An interface is an <a href="https://en.wikipedia.org/wiki/Abstract_type"><strong>abstract type</strong></a>. It doesn't expose the representation or internal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods.</p>
<h4 id="the-iowriter-interface">The <code>io.Writer</code> interface *</h4>
<p>This book has used two similar functions for string formatting:</p>
<ul>
<li><code>fmt.Printf</code>, which writes the result to the standard output (a file)</li>
<li><code>fmt.Sprintf</code>, which returns the result as a string</li>
</ul>
<p>Thanks to interfaces, both of these functions are in effect wrappers around a third function, <code>fmt.Fprintf</code>, which is agnostic about what happens to the result it computes:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">func</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The <code>F</code> prefix of <code>Fprintf</code> stands for <em>file</em> and indicates that the formatted output should be written to the file provided as the first argument.</p>
<ul>
<li>In the <code>Printf</code> case, the argument, <code>os.Stdout</code>, is an <a href="https://golang.org/pkg/os/#File"><code>*os.File</code></a>.</li>
<li>In the <code>Sprintf</code> case, the argument is not a file but superficially resembles one: <code>&amp;buf</code> is a pointer to a memory buffer to which bytes can be written.</li>
</ul>
<p>The first parameter of <code>Fprintf</code> is not a file either. It's an <a href="https://golang.org/pkg/io/#Writer"><code>io.Writer</code></a>, which is an interface type with the following declaration:</p>
<p><small><a href="https://github.com/golang/go/blob/master/src/io/io.go">go/src/io/io.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">io</span>

<span class="c1">// Writer is the interface that wraps the basic Write method.</span>
<span class="c1">//</span>
<span class="c1">// Write writes len(p) bytes from p to the underlying data stream.</span>
<span class="c1">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span>
<span class="c1">// and any error encountered that caused the write to stop early.</span>
<span class="c1">// Write must return a non-nil error if it returns n &lt; len(p).</span>
<span class="c1">// Write must not modify the slice data, even temporarily.</span>
<span class="c1">//</span>
<span class="c1">// Implementations must not retain p.</span>
<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The <code>io.Writer</code> interface defines the contract between <code>Fprintf</code> and its callers.</p>
<ul>
<li>The contract requires that the caller provide a value of a concrete type like <code>*os.File</code> or <code>*bytes.Buffer</code> that has a method called <code>Write</code> with the appropriate signature and behavior.</li>
<li>The contract guarantees that <code>Fprintf</code> will do its job given any value that satisfies the <code>io.Writer</code> interface.</li>
<li><code>Fprintf</code> may not assume that it is writing to a file or to memory, only that it can call <code>Write</code>.</li>
</ul>
<p>Because <code>fmt.Fprintf</code> assumes nothing about the representation of the value and relies only on the behaviors guaranteed by the <code>io.Writer</code> contract, we can safely pass a value of any concrete type that satisfies <code>io.Writer</code> as the first argument to <code>fmt.Fprintf</code>. This freedom to substitute one type for another that satisfies the same interface is called <em>substitutability</em>, and is a hallmark of object-oriented programming.</p>
<p>The following example uses a new type. The <code>Write</code> method of the <code>*ByteCounter</code> type below merely counts the bytes written to it before discarding them. (The conversion is required to make the types of <code>len(p)</code> and <code>*c</code> match in the <code>+=</code> assignment statement.)</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/bytecounter/main.go">gopl.io/ch7/bytecounter/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ByteCounter</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ByteCounter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">c</span> <span class="o">+=</span> <span class="nx">ByteCounter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="c1">// convert int to ByteCounter</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>Since <code>*ByteCounter</code> satisfies the <code>io.Writer</code> contract, we can pass it to <code>Fprintf</code>; the <code>ByteCounter</code> correctly accumulates the length of the result.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">c</span> <span class="nx">ByteCounter</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &quot;5&quot;, = len(&quot;hello&quot;)</span>

<span class="nx">c</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset the counter</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="p">=</span> <span class="s">&quot;Dolly&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;hello, %s&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &quot;12&quot;, = len(&quot;hello, Dolly&quot;)</span>
</pre></div>


<h4 id="the-fmtstringer-interface">The <code>fmt.Stringer</code> interface *</h4>
<p>Besides <code>io.Writer</code>, <code>fmt.Stringer</code> is another interface of great importance to the <code>fmt</code> package. <code>Fprintf</code> and <code>Fprintln</code> provide a way for types to control how their values are printed. For example:</p>
<ul>
<li>In <a href="../ch2/#type-declarations">Section 2.5</a>, we defined a <code>String</code> method for the <code>Celsius</code> type so that temperatures would print as "<code>100°C</code>.</li>
<li>In <a href="../ch6/#example-bit-vector-type">Section 6.5</a>, we equipped <code>*IntSet</code> with a <code>String</code> method so that sets would be rendered using traditional set notation like "<code>{1 2 3}</code>".</li>
</ul>
<p>Declaring a <code>String</code> method makes a type satisfy <code>fmt.Stringer</code>, which is one of the most widely used interfaces of all:</p>
<p><small><a href="https://github.com/golang/go/blob/master/src/fmt/print.go">go/src/fmt/print.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">fmt</span>

<span class="c1">// The String method is used to print values passed</span>
<span class="c1">// as an operand to any format that accepts a string</span>
<span class="c1">// or to an unformatted printer such as Print.</span>
<span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>


<p><a href="#type-assertions">Section 7.10</a> will explain how the <code>fmt</code> package discovers which values satisfy this interface.</p>
<h3 id="interface-types">Interface Types</h3>
<p>An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface.</p>
<p>The <code>io.Writer</code> type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, such as files, memory buffers, network connections, HTTP clients, archivers and hashers. The <code>io</code> package defines many other useful interfaces. A <code>Reader</code> represents any type from which you can read bytes, and a <code>Closer</code> is any value that you can close, such as a file or a network connection. (Notice the naming convention for many of Go's single-method interfaces.)</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">io</span>

<span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</pre></div>


<p>The following are examples of new interface types as combinations of existing ones:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadWriteCloser</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
    <span class="nx">Closer</span>
<span class="p">}</span>
</pre></div>


<p>The syntax used above, which resembles <a href="../ch4#struct-embedding-and-anonymous-fields">struct embedding</a>, enables us to name another interface as a shorthand for writing out all of its methods. This is called <em>embedding</em> an interface. We could have written <code>io.ReadWriter</code> without embedding like this:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>We can even use a mixture of the two styles:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">Writer</span>
<span class="p">}</span>
</pre></div>


<p>All three declarations have the same effect. The order in which the methods appear is immaterial. All that matters is the set of methods.</p>
<h3 id="interface-satisfaction">Interface Satisfaction</h3>
<p>A type <em>satisfies</em> an interface if it possesses all the methods the interface requires. For example:</p>
<ul>
<li>An <code>*os.File</code> satisfies <code>io.Reader</code>, <code>Writer</code>, <code>Closer</code>, and <code>ReadWriter</code>.</li>
<li>A <code>*bytes.Buffer</code> satisfies <code>Reader</code>, <code>Writer</code>, and <code>ReadWriter</code>, but does not satisfy <code>Closer</code> because it does not have a <code>Close</code> method.</li>
</ul>
<p>As a shorthand, Go programmers often say that a concrete type "is a" particular interface type, meaning that it satisfies the interface. For example:</p>
<ul>
<li>A <code>*bytes.Buffer</code> is an <code>io.Writer</code>.</li>
<li>An <code>*os.File</code> is an <code>io.ReadWriter</code>.</li>
</ul>
<p>The assignability rule (<a href="../ch2/##assignability">Section 2.4.2</a>) for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface. For example:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>           <span class="c1">// OK: *os.File has Write method</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>   <span class="c1">// OK: *bytes.Buffer has Write method</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>         <span class="c1">// compile error: time.Duration lacks Write method</span>

<span class="kd">var</span> <span class="nx">rwc</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriteCloser</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>         <span class="c1">// OK: *os.File has Read, Write, Close methods</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// compile error: *bytes.Buffer lacks Close method</span>
</pre></div>


<p>This rule applies even when the right-hand side is itself an interface:</p>
<div class="codehilite"><pre><span class="nx">w</span> <span class="p">=</span> <span class="nx">rwc</span>     <span class="c1">// OK: io.ReadWriteCloser has Write method</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nx">w</span>     <span class="c1">// compile error: io.Writer lacks Close method</span>
</pre></div>


<p>We should explain one subtlety in what it means for a type to have a method. Recall from <a href="../ch6/#methods-with-a-pointer-receiver">Section 6.2</a> that for each named concrete type <code>T</code>, some of its methods have a receiver of type <code>T</code> itself whereas others require a <code>*T</code> pointer. Recall also that it is legal to call a <code>*T</code> method on an argument of type <code>T</code> as long as the argument is a variable; the compiler implicitly takes its address. However, this is mere syntactic sugar: a value of type <code>T</code> does not possess all the methods that a <code>*T</code> pointer does; as a result, <code>T</code> might satisfy fewer interfaces.</p>
<p>For example, the <code>String</code> method of the <code>IntSet</code> type from <a href="../ch6/#example-bit-vector-type">Section 6.5</a> requires a pointer receiver, so we cannot call that method on a non-addressable <code>IntSet</code> value:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">IntSet</span><span class="p">{}.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// compile error: String requires *IntSet receiver</span>
</pre></div>


<p>But we can call it on an <code>IntSet</code> variable:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">s</span> <span class="nx">IntSet</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// OK: s is a variable and &amp;s has a String method</span>
</pre></div>


<p>However, since only <code>*IntSet</code> has a <code>String</code> method, only <code>*IntSet</code> satisfies the <code>fmt.Stringer</code> interface:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">s</span> <span class="c1">// OK</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="nx">s</span>  <span class="c1">// compile error: IntSet lacks String method</span>
</pre></div>


<p><a href="ch12.md#displaying-the-methods-of-a-type">Section 12.8</a> includes a program that prints the methods of an arbitrary value, and the <code>godoc -analysis=type</code> tool (<a href="../ch10/#documenting-packages">Section 10.7.4</a>) displays the methods of each type and the relationship between interfaces and concrete types.</p>
<p>An interface wraps and conceals the concrete type and value that it holds. <u>Only the methods revealed by the interface type may be called, even if the concrete type has others</u>:</p>
<div class="codehilite"><pre><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// OK: *os.File has Write method</span>
<span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// OK: *os.File has Close method</span>

<span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// OK: io.Writer has Write method</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// compile error: io.Writer lacks Close method</span>
</pre></div>


<h4 id="empty-interface-interface">Empty interface: <code>interface{}</code> *</h4>
<p>An interface with more methods, such as <code>io.ReadWriter</code>, tells us more about the values it contains, and places greater demands on the types that implement it, than does an interface with fewer methods such as <code>io.Reader</code>. Similarly, the type <code>interface{}</code>, which has no methods at all, tell us about nothing about the concrete types that satisfy it. This may seem useless, but in fact the type <code>interface{}</code>, which is called the <strong>empty interface</strong> type, is indispensable. Because the empty interface type places no demands on the types that satisfy it, we can assign any value to the empty interface.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">any</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">any</span> <span class="p">=</span> <span class="mf">12.34</span>
<span class="nx">any</span> <span class="p">=</span> <span class="s">&quot;hello&quot;</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>


<p>The empty interface type has been used in the very first example in this book, because it is what allows functions like <code>fmt.Println</code>, or <code>errorf</code> in <a href="../ch5/#anonymous-functions">Section 5.7</a>, to accept arguments of any type.</p>
<p>Having created an <code>interface{}</code> value containing a boolean, float, string, map, pointer, or any other type, we can do nothing directly to the value it holds since the interface has no methods. We need a way to get the value back out again, which can be done using a type assertion, discussed in <a href="#type-assertions">Section 7.10</a>.</p>
<p>Since interface satisfaction depends only on the methods of the two types involved, there is no need to declare the relationship between a concrete type and the interfaces it satisfies. However, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below asserts at compile time that a value of type <code>*bytes.Buffer</code> satisfies <code>io.Writer</code>:</p>
<div class="codehilite"><pre><span class="c1">// *bytes.Buffer must satisfy io.Writer</span>
<span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>


<p>We needn't allocate a new variable since any value of type <code>*bytes.Buffer</code> will do, even <code>nil</code>, which we write as <code>(*bytes.Buffer)(nil)</code> using an explicit conversion. Since we never intend to refer to <code>w</code>, we can replace it with the blank identifier, which makes more frugal variant:</p>
<div class="codehilite"><pre><span class="c1">// *bytes.Buffer must satisfy io.Writer</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</pre></div>


<p>Non-empty interface types such as <code>io.Writer</code> are most often satisfied by a pointer type, particularly when one or more of the interface methods implies some kind of mutation to the receiver, as the <code>Write</code> method does. A pointer to a struct is an especially common method-bearing type.</p>
<p>Pointer types are not the only types that satisfy interfaces, and even interfaces with mutator methods may be satisfied by other reference types. For example:</p>
<ul>
<li>Slice types with methods (<code>geometry.Path</code>, <a href="../ch6/#method-declarations">Section 6.1</a>)</li>
<li>Map types with methods (<code>url.Values</code>, <a href="../ch6/#nil-is-a-valid-receiver-value">Section 6.2.1</a>),</li>
<li>Function type with methods (<code>http.HandlerFunc</code>, <a href="#the-httphandler-interface">Section 7.7</a>).</li>
<li>Even basic types may satisfy interfaces: in <a href="#parsing-flags-with-flagvalue">Section 7.4</a>, <code>time.Duration</code> satisfies <code>fmt.Stringer</code>.</li>
</ul>
<p>A concrete type may satisfy many unrelated interfaces. For example, a program that organizes or sells digitized cultural artifacts might define the following set of concrete types:</p>
<div class="codehilite"><pre>Album
Book
Movie
Magazine
Podcast
TVEpisode
Track
</pre></div>


<p>Each abstraction of interest can be expressed as an interface. Some properties are common to all artifacts, such as a title, a creation date, and a list of creators (authors or artists).</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Artifact</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Title</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">Creators</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="nx">Created</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</pre></div>


<p>Other properties are restricted to certain types of artifacts. Properties of the printed word are relevant only to books and magazines, whereas only movies and TV episodes have a screen resolution.</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Text</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Pages</span><span class="p">()</span> <span class="kt">int</span>
    <span class="nx">Words</span><span class="p">()</span> <span class="kt">int</span>
    <span class="nx">PageSize</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Audio</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &quot;MP3&quot;, &quot;WAV&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Video</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &quot;MP4&quot;, &quot;WMV&quot;</span>
  <span class="nx">Resolution</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>These interfaces are not the only useful way to group related concrete types together and express the facets they share in common. We may discover other groupings later. For example, if we find we need to handle <code>Audio</code> and <code>Video</code> items in the same way, we can define a <code>Streamer</code> interface to represent their common aspects without changing any existing type declarations.</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Streamer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>


<p>Each grouping of concrete types based on their shared behaviors can be expressed as an interface type. Unlike class-based languages, in which the set of interfaces satisfied by a class is explicit, in Go we can define new abstractions or groupings of interest when we need them, without modifying the declaration of the concrete type. This is particularly useful when the concrete type comes from a package written by a different author. Of course, there do need to be underlying commonalities in the concrete types.</p>
<h3 id="parsing-flags-with-flagvalue">Parsing Flags with <code>flag.Value</code></h3>
<h3 id="interface-values">Interface Values</h3>
<h3 id="the-httphandler-interface">The <code>http.Handler</code> Interface</h3>
<h3 id="sorting-with-sortinterface">Sorting with <code>sort.Interface</code></h3>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>