<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch8/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 8. Goroutines and Channels - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch8.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-8-goroutines-and-channels">Chapter 8. Goroutines and Channels</a></li>
        
    
        <li class="main "><a href="#goroutines">Goroutines</a></li>
        
    
        <li class="main "><a href="#example-concurrent-clock-server">Example: Concurrent Clock Server</a></li>
        
    
        <li class="main "><a href="#example-concurrent-echo-server">Example: Concurrent Echo Server</a></li>
        
    
        <li class="main "><a href="#channels">Channels</a></li>
        
            <li><a href="#unbuffered-channels">Unbuffered Channels</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-8-goroutines-and-channels"><strong>Chapter 8. Goroutines and Channels</strong></h3>
<p>Concurrent programming, the expression of a program as a composition of several autonomous activities, has never been more important than it is today.</p>
<p>Go enables two styles of concurrent programming.</p>
<ul>
<li>This chapter presents goroutines and channels, which support <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">communicating sequential processes</a> (CSP), a model of concurrency in which values are passed between independent activities (goroutines) but variables are for the most part confined to a single activity.</li>
<li><a href="ch9.md">Chapter 9</a> covers some aspects of the more traditional model of <strong>shared memory multithreading</strong>, which will be familiar to those who used threads in other mainstream languages.</li>
</ul>
<h3 id="goroutines">Goroutines</h3>
<p>In Go, each concurrently executing activity is called a <em>goroutine</em>. If you have used operating system threads or threads in other languages, then you can assume for now that a goroutine is similar to a thread.  The differences between threads and goroutines are essentially quantitative, not qualitative, and will be described in <a href="ch9.md#goroutines-and-threads">Section 9.8</a>.</p>
<p>When a program starts, its only goroutine is the one that calls the <code>main</code> function, so we call it the <em>main goroutine</em>. New goroutines are created by the <code>go</code> statement:</p>
<ul>
<li>Syntactically, a <code>go</code> statement is an ordinary function or method call prefixed by the keyword <code>go</code>.</li>
<li>A <code>go</code> statement causes the function to be called in a newly created goroutine. The go statement itself completes immediately.</li>
</ul>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">()</span>    <span class="c1">// call f(); wait for it to return</span>
<span class="k">go</span> <span class="nx">f</span><span class="p">()</span> <span class="c1">// create a new goroutine that calls f(); don&#39;t wait</span>
</pre></div>


<p>In the example below, the main goroutine computes the 45th Fibonacci number using an inefficient recursive algorithm, which runs for an appreciable time, during which we provide the user with a visual indication that the program is still running, by displaying an animated textual "spinner".</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/spinner/main.go">gopl.io/ch8/spinner/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">spinner</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">45</span>
    <span class="nx">fibN</span> <span class="o">:=</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// slow</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\rFibonacci(%d) = %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fibN</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">spinner</span><span class="p">(</span><span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">`-\|/`</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\r%c&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>After several seconds of animation, the <code>fib(45)</code> call returns and the main function prints its result:</p>
<div class="codehilite"><pre>Fibonacci(45) = 1134903170
</pre></div>


<p>The <code>main</code> function then returns. When this happens, all goroutines are abruptly terminated and the program exits. Other than by returning from <code>main</code> or exiting the program, there is no programmatic way for one goroutine to stop another, but as we will see later, there are ways to communicate with a goroutine to request that it stop itself.</p>
<p>Notice how the program is expressed as the composition of two autonomous activities, spinning and Fibonacci computation. Each is written as a separate function but both make progress concurrently.</p>
<h3 id="example-concurrent-clock-server">Example: Concurrent Clock Server</h3>
<p>Networking is a natural domain to use concurrency since servers typically handle many connections from their clients at once, each client being essentially independent of the others. This section introduces the <a href="https://golang.org/pkg/net/"><code>net</code></a> package, which provides the components for building networked client and server programs that communicate over TCP, UDP, or Unix domain sockets. The <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a> package introduced since <a href="../ch1/">Chapter 1</a> is built on top of functions from the <code>net</code> package.</p>
<p>The first example is a sequential clock server that writes the current time to the client once per second:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/clock1/clock.go">gopl.io/ch8/clock1/clock.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Clock1 is a TCP server that periodically writes the time.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle one connection at a time</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Format</span><span class="p">(</span><span class="s">&quot;15:04:05\n&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="c1">// e.g., client disconnected</span>
        <span class="p">}</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The <code>Listen</code> function creates a <a href="https://golang.org/pkg/net/#Listener"><code>net.Listener</code></a>, an object that listens for incoming connections on a network port, in this case TCP port <code>localhost:8000</code>. The listener's <code>Accept</code> method blocks until an incoming connection request is made, then returns a <a href="https://golang.org/pkg/net/#Conn"><code>net.Conn</code></a> object representing the connection.</li>
<li>The <code>handleConn</code> function handles one complete client connection.<ul>
<li>In a loop, it writes the current time, <code>time.Now()</code>, to the client.</li>
<li>Since <code>net.Conn</code> satisfies the <code>io.Writer</code> interface, we can write directly to it.</li>
<li>The loop ends when the write fails, most likely because the client has disconnected, at which point <code>handleConn</code> closes its side of the connection using a deferred call to <code>Close</code> and goes back to waiting for another connection request.</li>
</ul>
</li>
<li>The <code>time.Time.Format</code> method provides a way to format date and time information by example. Its argument is a template indicating how to format a reference time, specifically <code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>.<ul>
<li>The reference time has eight components. Any collection of them can appear in the <code>Format</code> string in any order and in a number of formats; the selected components of the date and time will be displayed in the selected formats. This example uses the hour, minute, and second of the time.</li>
<li>The <code>time</code> package defines templates for many standard time formats, such as <a href="https://golang.org/pkg/time/#pkg-constants"><code>time.RFC1123</code></a>. The same mechanism is used in reverse when parsing a time using <code>time.Parse</code>.</li>
</ul>
</li>
</ul>
<p>To connect to the server, we need a client program such as <code>nc</code> ("netcat"), a standard utility program for manipulating network connections:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch8/clock1
<span class="gp">$</span> ./clock1 <span class="p">&amp;</span>
<span class="gp">$</span> nc localhost 8000
<span class="go">13:58:54</span>
<span class="go">13:58:55</span>
<span class="go">13:58:56</span>
<span class="go">13:58:57</span>
<span class="go">^C</span>
</pre></div>


<p>The client displays the time sent by the server each second until we interrupt the client with Control-C, which on Unix systems is echoed as <code>^C</code> by the shell. We can also use <code>telnet</code>, or the following simple Go version of <code>netcat</code> that uses <code>net.Dial</code> to connect to a TCP server:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat2/netcat.go">gopl.io/ch8/netcat1/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Netcat1 is a read-only TCP client.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>This program reads data from the connection and writes it to the standard output until an end-of-file condition or an error occurs. The <code>mustCopy</code> function is a utility used in several examples in this section.</p>
<p>We run two clients at the same time on different terminals, one shown to the left and one to the right:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/netcat1
$ ./netcat1
13:58:54                        $ ./netcat1
13:58:55
13:58:56
^C
                                13:58:57
                                13:58:58
                                13:58:59
                                ^C
$ killall clock1
</pre></div>


<p>The second client must wait until the first client is finished because the server is sequential; it deals with only one client at a time.  Only one small change is needed to make the server concurrent: adding the <code>go</code> keyword to the call to <code>handleConn</code> causes each call to run in its own goroutine.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/clock2/clock.go">gopl.io/ch8/clock2/clock.go</a></small></p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle connections concurrently</span>
<span class="p">}</span>
</pre></div>


<p>Now, multiple clients can receive the time at once.</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/clock2
$ ./clock2 &amp;
$ go build gopl.io/ch8/netcat1
$ ./netcat1
14:02:54                     $ ./netcat1
14:02:55                     14:02:55
14:02:56                     14:02:56
14:02:57                     ^C
14:02:58
14:02:59                     $ ./netcat1
14:03:00                     14:03:00
14:03:01                     14:03:01
^C                           14:03:02
                             ^C
</pre></div>


<h3 id="example-concurrent-echo-server">Example: Concurrent Echo Server</h3>
<p>The clock server used one goroutine per connection. In this section, we'll build an echo server that uses multiple goroutines per connection. Most echo servers merely write whatever they read, which can be done with this trivial version of <code>handleConn</code>:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>This version of echo server simulates the reverberations of a real echo, with the response loud at first ("HELLO!"), then moderate ("Hello!") after a delay, then quiet ("hello!") before fading to nothing:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/reverb1/reverb.go">gopl.io/ch8/reverb1/reverb.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">shout</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">shout</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The following client program sends terminal input to the server while also copying the server response to the output:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat2/netcat.go">gopl.io/ch8/netcat2/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>While the main goroutine reads the standard input and sends it to the server, a second goroutine reads and prints the server's response. When the main goroutine encounters the end of the input (for example, after the user types Control-D (<code>^D</code>)) at the terminal, the program stops, even if the other goroutine still has work to do. (<a href="#unbuffered-channels">Section 8.4.1</a> discusses how to make the program wait for both sides to finish)</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/reverb1
$ ./reverb1 &amp;
$ go build gopl.io/ch8/netcat2
$ ./netcat2
Hello?
    HELLO?
    Hello?
    hello?
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    is there anybody there?
    YOOO-HOOO!
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb1
</pre></div>


<p>Notice that the third shout from the client is not dealt with until the second shout has petered out, which is not very realistic. A real echo would consist of the <em>composition</em> of the three independent shouts. To simulate it, more goroutines are needed; all we need to do is add the <code>go</code> keyword, this time to the call to <code>echo</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/reverb2/reverb.go">gopl.io/ch8/reverb2/reverb.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The arguments to the function started by <code>go</code> are evaluated when the <code>go</code> statement itself is executed; thus <code>input.Text()</code> is evaluated in the main goroutine.</p>
<p>Now the echoes are concurrent and overlap in time:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/reverb2
$ ./reverb2 &amp;
$ ./netcat2
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    YOOO-HOOO!
    is there anybody there?
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb2
</pre></div>


<p><u>All that was required to make the server use concurrency, not just to handle connections from multiple clients but even within a single connection, was the insertion of two <code>go</code> keywords.</u></p>
<p>However in adding these keywords, we had to consider carefully that it is safe to call methods of <code>net.Conn</code> concurrently, which is not true for most types. The next chapter discusses the crucial concept of concurrency safety in the.</p>
<h3 id="channels">Channels</h3>
<p>If goroutines are the activities of a concurrent Go program, channels are the connections between them.</p>
<ul>
<li>A channel is a communication mechanism that enables one goroutine to send values to another goroutine.</li>
<li>Each channel is a conduit for values of a particular type, called the channel's <em>element type</em>. The type of a channel whose elements have type int is written <code>chan int</code>.</li>
</ul>
<p>To create a channel, use the built-in <code>make</code> function:</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// ch has type &#39;chan int&#39;</span>
</pre></div>


<p>A channel is a reference to the data structure created by <code>make</code>.</p>
<ul>
<li>When we copy a channel or pass one as an argument to a function, we are copying a reference, so caller and callee refer to the same data structure.</li>
<li>As with other reference types, the zero value of a channel is <code>nil</code>.</li>
<li>Two channels of the same type may be compared using <code>==</code>. The comparison is true if both are references to the same channel data structure. A channel may also be compared to <code>nil</code>.</li>
</ul>
<p>A channel has two principal operations, <em>send</em> and <em>receive</em>, collectively known as <em>communications</em>. A send statement transmits a value from one goroutine, through the channel, to another goroutine executing a corresponding receive expression.</p>
<p>Both operations are written using the <code>&lt;-</code> operator.</p>
<ul>
<li>In a send statement, the <code>&lt;-</code> separates the channel and value operands.</li>
<li>In a receive expression, <code>&lt;-</code> precedes the channel operand. A receive expression whose result is not used is a valid statement.</li>
</ul>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="c1">// a send statement</span>

<span class="nx">x</span><span class="p">=</span><span class="o">&lt;-</span><span class="nx">ch</span>  <span class="c1">// a receive expression in an assignment statement</span>
<span class="o">&lt;-</span><span class="nx">ch</span>    <span class="c1">// a receive statement; result is discarded</span>
</pre></div>


<p>Channels support a third operation, <em>close</em>, which sets a flag indicating that no more values will ever be sent on this channel.</p>
<ul>
<li>Send operations on a closed channel will panic.</li>
<li>Receive operations on a closed channel yield the values that have been sent until no more values are left; any receive operations thereafter complete immediately and yield the zero value of the channel's element type.</li>
</ul>
<p>To close a channel, call the built-in <code>close</code> function:</p>
<div class="codehilite"><pre><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</pre></div>


<p>A channel created with a simple call to <code>make</code> is called an <em>unbuffered</em> channel. <code>make</code> accepts an optional second argument, an integer called the channel's <em>capacity</em>. If the capacity is nonzero, <code>make</code> creates a <code>buffered</code> channel.</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c1">// unbuffered channel</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// unbuffered channel</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// buffered channel with capacity 3</span>
</pre></div>


<p>Unbuffered channels are discussed in <a href="#unbuffered-channels">Section 8.4.1</a> and buffered channels in <a href="#buffered-channels">Section 8.4.4</a>.</p>
<h4 id="unbuffered-channels">Unbuffered Channels</h4>
<ul>
<li>A send operation on an unbuffered channel blocks the sending goroutine until another goroutine executes a corresponding receive on the same channel, at which point the value is transmitted and both goroutines may continue.</li>
<li>Conversely, if the receive operation was attempted first, the receiving goroutine is blocked until another goroutine performs a send on the same channel.</li>
</ul>
<p>Communication over an unbuffered channel causes the sending and receiving goroutines to <em>synchronize</em>. Because of this, unbuffered channels are sometimes called <em>synchronous</em> channels. When a value is sent on an unbuffered channel, the receipt of the value happens <em>before</em> the reawakening of the sending goroutine.</p>
<p>In discussions of concurrency:</p>
<ul>
<li>When we say <em>x happens before y</em>, we don't mean merely that <em>x</em> occurs earlier in time than <em>y</em>. We mean that it is guaranteed to do so and that all its prior effects (e.g. updates to variables) are complete and that you may rely on them.</li>
<li>When we say <em>x is concurrent with y</em>, we mean <em>x</em> neither happens before <em>y</em> nor after <em>y</em>.<ul>
<li>This doesn't mean that <em>x</em> and <em>y</em> are necessarily simultaneous; it merely means that we cannot assume anything about their ordering.</li>
<li>As discussed in the next chapter, it's necessary to order certain events during the program's execution to avoid the problems that arise when two goroutines access the same variable concurrently.</li>
</ul>
</li>
</ul>
<p>The client program in <a href="#example-concurrent-echo-server">Section 8.3</a> copies input to the server in its main goroutine, so the client program terminates as soon as the input stream closes, even if the background goroutine is still working. To make the program wait for the background goroutine to complete before exiting, we use a channel to synchronize the two goroutines:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat3/netcat.go">gopl.io/ch8/netcat3/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">)</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// signal the main goroutine</span>
    <span class="p">}()</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="o">&lt;-</span><span class="nx">done</span> <span class="c1">// wait for background goroutine to finish</span>
<span class="p">}</span>
</pre></div>


<p>When the user closes the standard input stream, <code>mustCopy</code> returns and the main goroutine calls <code>conn.Close()</code>, closing both halves of the network connection:</p>
<ul>
<li>Closing the write half of the connection causes the server to see an end-of-file condition.</li>
<li>Closing the read half causes the background goroutine's call to <code>io.Copy</code> to return a "read from closed connection" error, which is why we've removed the error logging. Notice that the go statement calls a literal function, a common construction.</li>
</ul>
<p>Before it returns, the background goroutine logs a message, then sends a value on the done channel. The main goroutine waits until it has received this value before returning. As a result, the program always logs the "<code>done</code>" message before exiting.</p>
<p>Messages sent over channels have two important aspects. Each message has a value, but sometimes the fact of communication and the moment at which it occurs are important. We call messages <em>events</em> when we wish to stress this aspect. When the event carries no additional information, that is, its sole purpose is synchronization, we'll emphasize this by using a channel whose element type is <code>struct{}</code>, though it's common to use a channel of <code>bool</code> or <code>int</code> for the same purpose since <code>done &lt;- 1</code> is shorter than <code>done &lt;- struct{}{}</code>.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>