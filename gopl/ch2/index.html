<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch2/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 2. Program Structure - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
            
            
            
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                    
                      
                        <li class="active">
                            <a href="./">Chapter 2. Program Structure</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TWGR <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../twgr/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../twgr/ch1/">Chapter 1. Bootstrapping your Ruby literacy</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../twgr/ch2/">Chapter 2. Objects, methods, and local variables</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">SPEC <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                      
                        <li >
                            <a href="../../spec/">Contents</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../spec/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../spec/ch2/">Chapter 2. Methodology</a>
                        </li>
                      
                    
                      
                        <li >
                            <a href="../../spec/ch3/">Chapter 3. Operating Systems</a>
                        </li>
                      
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
            
            
            
            
            
            
                <li >
                    <a href="../../roadmap/">Roadmap</a>
                </li>
            
            
            
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch2.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-2-program-structure">Chapter 2. Program Structure</a></li>
        
    
        <li class="main "><a href="#names">Names</a></li>
        
            <li><a href="#local-and-exported-names">Local and exported names *</a></li>
        
            <li><a href="#naming-convention-and-style">Naming convention and style *</a></li>
        
    
        <li class="main "><a href="#declarations">Declarations</a></li>
        
    
        <li class="main "><a href="#variables">Variables</a></li>
        
            <li><a href="#short-variable-declarations">Short Variable Declarations</a></li>
        
            <li><a href="#pointers">Pointers</a></li>
        
            <li><a href="#the-new-function">The new Function</a></li>
        
            <li><a href="#lifetime-of-variables">Lifetime of Variables</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-2-program-structure"><strong>Chapter 2. Program Structure</strong></h3>
<p>This chapter provides details about the basic structural elements of a Go program.</p>
<h3 id="names">Names</h3>
<p>In Go, the names of functions, variables, constants, types, statement labels, and packages follow a simple rule: a name begins with a letter (anything that Unicode deems a letter) or an underscore and may have any number of additional letters, digits, and underscores. The names are case-sensitive: <code>heapSort</code> and <code>Heapsort</code> are different names.</p>
<p>Go has 25 keywords like <code>if</code> and <code>switch</code> that may be used only where the syntax permits; they can’t be used as names.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>break</code></td>
<td><code>default</code></td>
<td><code>func</code></td>
<td><code>interface</code></td>
</tr>
<tr>
<td><code>case</code></td>
<td><code>defer</code></td>
<td><code>go</code></td>
<td><code>map</code></td>
</tr>
<tr>
<td><code>chan</code></td>
<td><code>else</code></td>
<td><code>goto</code></td>
<td><code>package</code></td>
</tr>
<tr>
<td><code>const</code></td>
<td><code>fallthrough</code></td>
<td><code>if</code></td>
<td><code>range</code></td>
</tr>
<tr>
<td><code>continue</code></td>
<td><code>for</code></td>
<td><code>import</code></td>
<td><code>return</code></td>
</tr>
</tbody>
</table>
<p>In addition, there are about three dozen <em>predeclared</em> names like <code>int</code> and <code>true</code> for built-in constants, types, and functions:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Constants:</td>
<td><code>true</code> <code>false</code> <code>iota</code> <code>nil</code></td>
</tr>
<tr>
<td>Types:</td>
<td><code>int</code> <code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code> <code>uint</code> <code>uint8</code> <code>uint16</code> <code>uint32</code> <code>uint64</code> <code>uintptr</code> <code>float32</code> <code>float64</code> <code>complex128</code> <code>complex64</code> <code>bool</code> <code>byte</code> <code>rune</code> <code>string</code> <code>error</code></td>
</tr>
<tr>
<td>Functions:</td>
<td><code>make</code> <code>len</code> <code>cap</code> <code>new</code> <code>append</code> <code>copy</code> <code>close</code> <code>delete</code> <code>complex</code> <code>real</code> <code>imag</code> <code>panic</code> <code>recover</code></td>
</tr>
</tbody>
</table>
<p>These names are not reserved, so you may use them in declarations. Beware of the potential for confusion.</p>
<h4 id="local-and-exported-names">Local and exported names *</h4>
<p>If an entity is:</p>
<ul>
<li>Declared within a function: it is <em>local</em> to that function.</li>
<li>Declared outside of a function: it is visible in all files of the package to which it belongs.</li>
</ul>
<p>The case of the first letter of a name determines its visibility across package boundaries:</p>
<ul>
<li>If the name begins with an upper-case letter, it is <em>exported</em> (visible and accessible outside of its own package and may be referred to by other parts of the program), as with <code>Printf</code> in the <code>fmt</code> package.</li>
<li>Package names themselves are always in lower case.</li>
</ul>
<h4 id="naming-convention-and-style">Naming convention and style *</h4>
<ul>
<li>There is no limit on name length;</li>
<li>Short names are preferred, especially for local variables with small scopes (<code>i</code> is better than <code>theLoopIndex</code>);</li>
<li>The larger the scope of a name, the longer and more meaningful it should be.</li>
<li><a href="https://en.wikipedia.org/wiki/CamelCase">Camel case</a> are used when forming names by combining words, e.g. <code>QuoteRuneToASCII</code> and <code>parseRequestLine</code> (instead of <code>quote_rune_to_ASCII</code> or <code>parse_request_line</code>).</li>
<li>The letters of acronyms and initialisms like <code>ASCII</code> and <code>HTML</code> are always rendered in the same case, so a function might be called <code>htmlEscape</code>, <code>HTMLEscape</code>, or <code>escapeHTML</code>, but not <code>escapeHtml</code>.</li>
</ul>
<h3 id="declarations">Declarations</h3>
<p>A <strong>declaration</strong> names a program entity and specifies its properties. There are four major kinds of declarations:</p>
<ol>
<li><code>var</code> (variables)</li>
<li><code>const</code> (constants)</li>
<li><code>type</code> (types)</li>
<li><code>func</code> (functions)</li>
</ol>
<p>This chapter discusses variables and types. Constants are disucssed in <a href="../ch3/">Chapter 3</a>, and functions in <a href="../ch5/">Chapter 5</a>.</p>
<p>Each <code>.go</code> file has declarations in the following order:</p>
<ol>
<li>A <code>package</code> declaration that says what package the file is part of.</li>
<li>Any <code>import</code> declarations</li>
<li>A sequence of package-level declarations of types, variables, constants, and functions, in any order.</li>
</ol>
<p>For example, the following program declares a constant, a function, and a couple of variables:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/boiling/main.go">gopl.io/ch2/boiling/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Boiling prints the boiling point of water.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">const</span> <span class="nx">boilingF</span> <span class="p">=</span> <span class="mf">212.0</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="p">=</span> <span class="nx">boilingF</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;boiling point = %g°F or %g°C\n&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="c1">// Output:</span>
    <span class="c1">// boiling point = 212°F or 100°C</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>Each package-level name is visible in all the files of the package.</li>
<li>Local declarations are visible only within the function in which they are declared.</li>
</ul>
<p>A function declaration has a name, a list of parameters an optional list of results (omitted if the function does not return anything), and the function body.</p>
<h3 id="variables">Variables</h3>
<p>A <code>var</code> declaration creates a variable of a particular type, attaches a name to it, and sets its initial value, with the general form:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">name</span> <span class="kd">type</span> <span class="p">=</span> <span class="nx">expression</span>
</pre></div>


<p><u>Either the type or the <code>= expression</code> part may be omitted, but not both:</u></p>
<ul>
<li>If the type is omitted, it is determined by the initializer expression.</li>
<li>If the expression is omitted, the initial value is the <strong>zero value</strong> for the type, which is:<ul>
<li>0 for numbers</li>
<li><code>false</code> for booleans</li>
<li><code>""</code> for strings</li>
<li><code>nil</code> for interfaces and reference types (slice, pointer, map, channel, function).</li>
</ul>
</li>
</ul>
<p>The zero value of an aggregate type like an array or a struct has the zero value of all of its elements or fields.</p>
<p>The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there is no such thing as an uninitialized variable. This simplifies code and often ensures sensible behavior of boundary conditions without extra work. For example,</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &quot;&quot;</span>
</pre></div>


<p>Go programmers often go to some effort to make the zero value of a more complicated type meaningful, so that variables begin life in a useful state.</p>
<p>It is possible to declare and optionally initialize a set of variables in a single declaration, with a matching list of expressions. Omitting the type allows declaration of multiple variables of different types:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span> <span class="c1">// int, int, int</span>
<span class="kd">var</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s">&quot;four&quot;</span> <span class="c1">// bool, float64, string</span>
</pre></div>


<ul>
<li>Initializers may be literal values or arbitrary expressions.</li>
<li>Package-level variables are initialized before <code>main</code> begins (<a href="#package-initialization">Section 2.6.2</a>).</li>
<li>Local variables are initialized as their declarations are encountered during function execution.</li>
</ul>
<p>A set of variables can also be initialized by calling a function that returns multiple values:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// os.Open returns a file and an error</span>
</pre></div>


<h4 id="short-variable-declarations">Short Variable Declarations</h4>
<p>Within a function, an alternate form called a short variable declaration may be used to declare and initialize local variables. It takes the form <code>name := expression</code>, and the type of name is determined by the type of expression. For exmaple (<a href="../ch1/#animated-gifs">Animated GIFs</a>),</p>
<h5 id="when-to-use-short-variable-declaration-and-var-declaration"><strong>When to use short variable declaration and <code>var</code> declaration</strong> *</h5>
<ul>
<li>Short variable declarations are used to declare and initialize the majority of local variables, for brevity and flexibility.</li>
<li>A <code>var</code> declaration tends to be reserved for:<ul>
<li>Local variables that need an explicit type that differs from that of the initializer expression;</li>
<li>Local variables when they will be assigned a value later and its initial value is unimportant.</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre><span class="nx">i</span> <span class="o">:=</span> <span class="mi">100</span> <span class="c1">// an int</span>
<span class="kd">var</span> <span class="nx">boiling</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">// a float64</span>
<span class="kd">var</span> <span class="nx">names</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Point</span>
</pre></div>


<p>As with <code>var</code> declarations, multiple variables may be declared and initialized in the same short variable declaration:</p>
<div class="codehilite"><pre><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>


<p>However, declarations with multiple initializer expressions should be used only when they help readability, such as for short and natural groupings like the initialization part of a for loop.</p>
<p>Keep in mind that <code>:=</code> is a declaration, whereas <code>=</code> is an assignment. A multi-variable declaration should not be confused with a <a href="#tuple-assignment">tuple assignment</a>, in which each variable on the left-hand side is assigned the corresponding value from the right-hand side:</p>
<div class="codehilite"><pre><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">i</span> <span class="c1">// swap values of i and j</span>
</pre></div>


<p>Like <code>var</code> declarations, short variable declarations may be used for calls to functions like <code>os.Open</code> that return two or more values:</p>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="c1">// ...use f...</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
</pre></div>


<h5 id="one-subtle-but-important-point"><strong>One subtle but important point</strong> *</h5>
<p>A short variable declaration does not necessarily declare all the variables on its left-hand side. If some of them were already declared in the same lexical block , then the short variable declaration acts like an assignment to those variables. For example,</p>
<div class="codehilite"><pre><span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span>
</pre></div>


<p>In the above code:</p>
<ul>
<li>The first statement declares both <code>in</code> and <code>err</code>.</li>
<li>The second declares <code>out</code> but only assigns a value to the existing <code>err</code> variable.</li>
</ul>
<p>A short variable declaration must declare at least one new variable. Therefore, the following code will not compile:</p>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span> <span class="c1">// compile error: no new variables</span>
</pre></div>


<p>The fix is to use an ordinary assignment for the second statement.</p>
<p>A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block are ignored.</p>
<h4 id="pointers">Pointers</h4>
<p>A <strong>variable</strong> is a piece of storage containing a value.</p>
<ul>
<li>Variables created by declarations are identified by a name, such as <code>x</code></li>
<li>Many other variables are identified only by expressions like <code>x[i]</code> or <code>x.f</code>.</li>
</ul>
<p>All these expressions read the value of a variable, except when they appear on the lefthand side of an assignment, in which case a new value is assigned to the variable.</p>
<p>A <strong>pointer</strong> value is the address of a variable. A pointer is thus the location at which a value is stored. Not every value has an address, but every variable does. With a pointer, we can read or update the value of a variable indirectly, without using or even knowing the name of the variable, if indeed it has a name.</p>
<h5 id="pointer-type-type-and-address-of-operators"><strong>Pointer type (<code>*type</code>) and address-of (<code>&amp;</code>) operators</strong> *</h5>
<p>If a variable is declared <code>var x int</code>, the expression <code>&amp;x</code> ("address of <code>x</code>") yields a pointer to an integer variable (a value of type <code>*int</code>, which is pronounced "pointer to <code>int</code>"). If this value is called <code>p</code>, we say "<code>p</code> points to <code>x</code>", or equivalently "<code>p</code> contains the address of <code>x</code>". The variable to which <code>p</code> points is written <code>*p</code>. The expression <code>*p</code> yields the value of that variable, an <code>int</code>, but since <code>*p</code> denotes a variable, it may also appear on the left-hand side of an assignment, in which case the assignment updates the variable.</p>
<div class="codehilite"><pre><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">x</span>          <span class="c1">// p, of type *int, points to x</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>  <span class="c1">// &quot;1&quot;</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>           <span class="c1">// equivalent to x = 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>   <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>Each component of a variable of aggregate type: a field of a struct or an element of an array, is also a variable and thus has an address too.</p>
<p>Variables are sometimes described as <em>addressable</em> values. Expressions that denote variables are the only expressions to which the <em>address-of</em> operator <code>&amp;</code> may be applied.</p>
<h5 id="comparing-pointers"><strong>Comparing pointers</strong> *</h5>
<p>The zero value for a pointer of any type is <code>nil</code>. The test <code>p != nil</code> is true if <code>p</code> points to a variable. Pointers are comparable; two pointers are equal if and only if they point to the same variable or both are <code>nil</code>.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// &quot;true false false&quot;</span>
</pre></div>


<p><u>It is perfectly safe for a function to return the address of a local variable.</u> For example:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">f</span><span class="p">()</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">v</span>
<span class="p">}</span>
</pre></div>


<p><u>The local variable <code>v</code> created by this particular call to <code>f</code> will remain in existence even after the call has returned, and the pointer <code>p</code> will still refer to it.</u> Each call of <code>f</code> returns a distinct value:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">()</span> <span class="o">==</span> <span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>


<p>Passing a pointer argument to a function makes it possible for the function to update the variable that was indirectly passed. For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">incr</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">p</span><span class="o">++</span> <span class="c1">// increments what p points to; does not change p</span>
    <span class="k">return</span> <span class="o">*</span><span class="nx">p</span>
<span class="p">}</span>

<span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
<span class="c1">// side effect: v is now 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// &quot;3&quot; (and v is 3)</span>
</pre></div>


<h5 id="pointer-aliasing"><strong>Pointer aliasing</strong> *</h5>
<p>Each time we take the address of a variable or copy a pointer, we create new aliases or ways to identify the same variable. For example, <code>*p</code> is an alias for <code>v</code>. Pointer aliasing is useful because it allows us to access a variable without using its name, but this is a double-edged sword: to find all the statements that access a variable, we have to know all its aliases. <u>Aliasing also occurs when we copy values of other reference types like slices, maps, and channels, and even structs, arrays, and interfaces that contain these types.</u></p>
<h5 id="pointer-and-the-flag-package"><strong>Pointer and the <code>flag</code> package</strong></h5>
<p>Pointers are key to the <code>flag</code> package, which uses a program’s command-line arguments to set the values of certain variables for the entire program. To illustrate, this variation on the earlier <code>echo</code> command takes two optional flags:</p>
<ul>
<li><code>-n</code> causes <code>echo</code> to omit the trailing newline that would normally be printed;</li>
<li><code>-s sep</code> causes it to separate the output arguments by the contents of the string <code>sep</code> instead of the default single space.</li>
</ul>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/echo4/main.go">gopl.io/ch2/echo4/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Echo4 prints its command-line arguments.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;flag&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&quot;n&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;omit trailing newline&quot;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">sep</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="s">&quot;separator&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">(),</span> <span class="o">*</span><span class="nx">sep</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">!</span><span class="o">*</span><span class="nx">n</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The function <code>flag.Bool</code> creates a new flag variable of type <code>bool</code>. It takes three arguments:</p>
<ul>
<li>The name of the flag (<code>"n"</code>),</li>
<li>The variable’s default value (<code>false</code>),</li>
<li>A message that will be printed if the user provides an invalid argument, an invalid flag, or <code>-h</code> or <code>-help</code>.</li>
</ul>
<p>This is similar to <code>flag.String</code>.</p>
<p>The variables <code>sep</code> and <code>n</code> are pointers to the flag variables, which must be accessed indirectly as <code>*sep</code> and <code>*n</code>.</p>
<p>When the program is run, it must call <code>flag.Parse</code> before the flags are used, to update the flag variables from their default values. The non-flag arguments are available from <code>flag.Args()</code> as a slice of strings. If <code>flag.Parse</code> encounters an error, it prints a usage message and calls <code>os.Exit(2)</code> to terminate the program.</p>
<p>The following are some test results:</p>
<div class="codehilite"><pre><span class="go">$ go build gopl.io/ch2/echo4</span>
<span class="go">$ ./echo4 a bc def</span>
<span class="go">a bc def</span>
<span class="go">$ ./echo4 -s / a bc def</span>
<span class="go">a/bc/def</span>
<span class="go">$ ./echo4 -n a bc def</span>
<span class="go">a bc def$</span>
<span class="go">$ ./echo4 -help</span>
<span class="go">Usage of ./echo4:</span>
<span class="go">  -n    omit trailing newline</span>
<span class="go">  -s string</span>
<span class="go">        separator (default &quot; &quot;)</span>
</pre></div>


<h4 id="the-new-function">The <code>new</code> Function</h4>
<p>Another way to create a variable is to use the built-in function <code>new</code>. The expression <code>new(T)</code> creates an <strong>unnamed variable</strong> (<a href="https://golang.org/ref/spec#Variables">anonymous variable</a>) of type <code>T</code>, initializes it to the zero value of <code>T</code>, and returns its address, which is a value of type <code>*T</code>.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>    <span class="c1">// p, of type *int, points to an unnamed int variable</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>  <span class="c1">// &quot;0&quot;</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>           <span class="c1">// sets the unnamed int to 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>  <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>A variable created with <code>new</code> is no different from an ordinary local variable whose address is taken, except that there’s no need to invent (and declare) a dummy name, and we can use <code>new(T)</code> in an expression. <u>Thus <code>new</code> is only a syntactic convenience, not a fundamental notion.</u></p>
<p>The two <code>newInt</code> functions below have identical behaviors:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">dummy</span> <span class="kt">int</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">dummy</span>
<span class="p">}</span>
</pre></div>


<p>Each call to new returns a distinct variable with a unique address:</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="nx">q</span><span class="p">)</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>


<p>There is one exception to this rule: two variables whose type carries no information and is therefore of size zero, such as <code>struct{}</code> or <code>[0]int</code>, may have the same address (depending on the implementation).</p>
<p>The <code>new</code> function is relatively rarely used because the most common unnamed variables are of struct types, for which the struct literal syntax (<a href="../ch4/#struct-literals">Section 4.4.1</a>) is more flexible.</p>
<p>Since new is a predeclared function, not a keyword, it’s possible to redefine the name for something else within a function, for example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">delta</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">new</span> <span class="o">-</span> <span class="nx">old</span> <span class="p">}</span>
</pre></div>


<p>Within <code>delta</code>, the built-in <code>new</code> function is unavailable.</p>
<h4 id="lifetime-of-variables">Lifetime of Variables</h4>
<p>The lifetime of a variable is the interval of time during which it exists as the program executes.</p>
<ul>
<li>The lifetime of a package-level variable is the entire execution of the program.</li>
<li>Local variables have dynamic lifetimes: a new instance is created each time the declaration statement is executed, and the variable lives on until it becomes <em>unreachable</em>, at which point its storage may be recycled.</li>
<li>Function parameters and results are also local variables; they are created each time their enclosing function is called.</li>
</ul>
<p>For example, in this excerpt from the Lissajous program of <a href="#animated-gifs">Section 1.4</a>:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="nx">cycles</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">;</span> <span class="nx">t</span> <span class="o">+=</span> <span class="nx">res</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">y</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="o">*</span><span class="nx">freq</span> <span class="o">+</span> <span class="nx">phase</span><span class="p">)</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">SetColorIndex</span><span class="p">(</span><span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">y</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span>
        <span class="nx">blackIndex</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The variable <code>t</code> is created each time the for loop begins.</li>
<li>New variables <code>x</code> and <code>y</code> are created on each iteration of the loop.</li>
</ul>
<h5 id="how-does-the-garbage-collector-know-that-a-variables-storage-can-be-reclaimed"><strong>How does the garbage collector know that a variable’s storage can be reclaimed?</strong> *</h5>
<p>The basic idea is that every package-level variable, and every local variable of each currently active function, can potentially be the start or root of a path to the variable in question, following pointers and other kinds of references that ultimately lead to the variable. If no such path exists, the variable has become unreachable, so it can no longer affect the rest of the computation.</p>
<p><u>Because the lifetime of a variable is determined only by whether or not it is reachable, a local variable may outlive a single iteration of the enclosing loop. It may continue to exist even after its enclosing function has returned.</u></p>
<h5 id="heap-or-stack"><strong>Heap or stack?</strong> *</h5>
<p>A compiler may choose to allocate local variables on the heap or on the stack, but this choice is not determined by whether <code>var</code> or <code>new</code> was used to declare the variable.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">global</span> <span class="o">*</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">global</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">y</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>


<p>In the above code:</p>
<ul>
<li><code>x</code> must be heap-allocated because it is still reachable from the variable <code>global</code> after <code>f</code> has returned, despite being declared as a local variable; we say <code>x</code> <em>escapes</em> from <code>f</code>.</li>
<li>Conversely, when <code>g</code> returns, the variable <code>*y</code> becomes unreachable and can be recycled. Since <code>*y</code> does not escape from <code>g</code>, it’s safe for the compiler to allocate *y on the stack, even though it was allocated with <code>new</code>.</li>
</ul>
<p>In any case, the notion of escaping is not something that you need to worry about in order to write correct code, though it’s good to keep in mind during performance optimization, since each variable that escapes requires an extra memory allocation.</p>
<h5 id="thoughts-on-garbage-collection"><strong>Thoughts on garbage collection</strong> *</h5>
<p>Garbage collection is a tremendous help in writing correct programs, but it does not relieve you of the burden of thinking about memory. You don’t need to explicitly allocate and free memory, but to write efficient programs you still need to be aware of the lifetime of variables.  For example, keeping unnecessary pointers to short-lived objects within long-lived objects, especially global variables, will prevent the garbage collector from reclaiming the short-lived objects.</p>
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<p>p32 on short variable declaration.</p>
<blockquote>
<p>A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block are ignored.</p>
</blockquote>
<p>What does "declarations in an outer block are ignored" mean?</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>