<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/unp/ch7/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 7. Socket Options - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 7. Socket Options</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">PER <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../per/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch1/">Chapter 1. A Tutorial Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch6/">Chapter 6. Functions and Functional Programming</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch7/">Chapter 7. Classes and Object-Oriented Programming</a>
                        </li>
                      
                        <li>
                            <a href="../../per/ch15/">Chapter 15. Data Structures, Algorithms, and Code Simplification</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TWGR <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../twgr/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../twgr/ch1/">Chapter 1. Bootstrapping your Ruby literacy</a>
                        </li>
                      
                        <li>
                            <a href="../../twgr/ch2/">Chapter 2. Objects, methods, and local variables</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">SPEC <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../spec/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch2/">Chapter 2. Methodology</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch3/">Chapter 3. Operating Systems</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch4/">Chapter 4. Observability Tools</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch5/">Chapter 5. Applications</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch6/">Chapter 6. CPUs</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch7/">Chapter 7. Memory</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch8/">Chapter 8. File Systems</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch9/">Chapter 9. Disks</a>
                        </li>
                      
                        <li>
                            <a href="../../spec/ch10/">Chapter 10. Network</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">BD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../bd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../bd/ch1/">Chapter 1. A new paradigm for Big Data</a>
                        </li>
                      
                        <li>
                            <a href="../../bd/ch2/">Chapter 2. Data model for Big Data</a>
                        </li>
                      
                        <li>
                            <a href="../../bd/ch3/">Chapter 3. Data model for Big Data: Illustration</a>
                        </li>
                      
                    </ul>
                </li>
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/unp/ch7.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-7-socket-options">Chapter 7. Socket Options</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#getsockopt-and-setsockopt-functions">getsockopt and setsockopt Functions</a></li>
        
    
        <li class="main "><a href="#checking-if-an-option-is-supported-and-obtaining-the-default">Checking if an Option Is Supported and Obtaining the Default</a></li>
        
    
        <li class="main "><a href="#socket-states">Socket States</a></li>
        
    
        <li class="main "><a href="#generic-socket-options">Generic Socket Options</a></li>
        
    
        <li class="main "><a href="#ipv4-socket-options">IPv4 Socket Options</a></li>
        
            <li><a href="#so_broadcast-socket-option">SO_BROADCAST Socket Option</a></li>
        
            <li><a href="#so_debug-socket-option">SO_DEBUG Socket Option</a></li>
        
            <li><a href="#so_dontroute-socket-option">SO_DONTROUTE Socket Option</a></li>
        
            <li><a href="#so_error-socket-option">SO_ERROR Socket Option</a></li>
        
            <li><a href="#so_keepalive-socket-option">SO_KEEPALIVE Socket Option</a></li>
        
            <li><a href="#so_linger-socket-option">SO_LINGER Socket Option</a></li>
        
    
        <li class="main "><a href="#icmpv6-socket-option">ICMPv6 Socket Option</a></li>
        
    
        <li class="main "><a href="#ipv6-socket-options">IPv6 Socket Options</a></li>
        
    
        <li class="main "><a href="#tcp-socket-options">TCP Socket Options</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-7-socket-options"><strong>Chapter 7. Socket Options</strong></h3>
<h3 id="introduction">Introduction</h3>
<p>There are various ways to get and set the options that affect a socket:</p>
<ul>
<li>The <code>getsockopt</code> and <code>setsockopt</code> functions.</li>
<li>The <code>fcntl</code> function, which is the POSIX way to set a socket for nonblocking I/O, signal-driven I/O, and to set the owner of a socket.</li>
<li>The <code>ioctl</code> function.</li>
</ul>
<h3 id="getsockopt-and-setsockopt-functions"><code>getsockopt</code> and <code>setsockopt</code> Functions</h3>
<p>These two functions apply only to sockets:</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">getsockopt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">setsockopt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">optval</span> <span class="kt">socklen_t</span> <span class="n">optlen</span><span class="p">);</span>

<span class="cm">/* Both return: 0 if OK,–1 on error */</span>
</pre></div>


<p>Arguments:</p>
<ul>
<li><em>sockfd</em> must refer to an open socket descriptor.</li>
<li><em>level</em> specifies the code in the system that interprets the option: the general socket code or some protocol-specific code (e.g., IPv4, IPv6, TCP, or SCTP).</li>
<li><em>optval</em> is a pointer to a variable from which the new value of the option is fetched by <code>setsockopt</code>, or into which the current value of the option is stored by <code>getsockopt</code>. The size of this variable is specified by the final argument <em>optlen</em>, as a value for <code>setsockopt</code> and as a value-result for <code>getsockopt</code>.</li>
</ul>
<p>The following table lists socket and IP-layer socket options for <code>getsockopt</code> and <code>setsockopt</code>.</p>
<table>
<thead>
<tr>
<th><em>level</em></th>
<th><em>optname</em></th>
<th><code>get</code></th>
<th><code>set</code></th>
<th>Description</th>
<th>Flag</th>
<th>Datatype</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SOL_SOCKET</code></td>
<td><code>SO_BROADCAST</code></td>
<td>x</td>
<td>x</td>
<td>Permit sending of broadcast datagrams</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_DEBUG</code></td>
<td>x</td>
<td>x</td>
<td>Enable debug tracing</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_DONTROUTE</code></td>
<td>x</td>
<td>x</td>
<td>Bypass routing table lookup</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_ERROR</code></td>
<td>x</td>
<td></td>
<td>Get pending error and clear</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_KEEPALIVE</code></td>
<td>x</td>
<td>x</td>
<td>Periodically test if connection still alive</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_LINGER</code></td>
<td>x</td>
<td>x</td>
<td>Linger on close if data to send</td>
<td></td>
<td><code>linger{}</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_OOBINLINE</code></td>
<td>x</td>
<td>x</td>
<td>Leave received out-of-band data inline</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_RCVBUF</code></td>
<td>x</td>
<td>x</td>
<td>Receive buffer size</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_SNDBUF</code></td>
<td>x</td>
<td>x</td>
<td>Send buffer size</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_RCVLOWAT</code></td>
<td>x</td>
<td>x</td>
<td>Receive buffer low-water mark</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_SNDLOWAT</code></td>
<td>x</td>
<td>x</td>
<td>Send buffer low-water mark</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_RCVTIMEO</code></td>
<td>x</td>
<td>x</td>
<td>Receive timeout</td>
<td></td>
<td><code>timeval{}</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_SNDTIMEO</code></td>
<td>x</td>
<td>x</td>
<td>Send timeout</td>
<td></td>
<td><code>timeval{}</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_REUSEADDR</code></td>
<td>x</td>
<td>x</td>
<td>Allow local address reuse</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_REUSEPORT</code></td>
<td>x</td>
<td>x</td>
<td>Allow local port reuse</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_TYPE</code></td>
<td>x</td>
<td></td>
<td>Get socket type</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>SO_USELOOPBACK</code></td>
<td>x</td>
<td>x</td>
<td>Routing socket gets copy of what it sends</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td><code>IPPROTO_IP</code></td>
<td><code>IP_HDRINCL</code></td>
<td>x</td>
<td>x</td>
<td>IP header included with data</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_OPTIONS</code></td>
<td>x</td>
<td>x</td>
<td>IP header options</td>
<td></td>
<td>(see text)</td>
</tr>
<tr>
<td></td>
<td><code>IP_RECVDSTADDR</code></td>
<td>x</td>
<td>x</td>
<td>Return destination IP address</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_RECVIF</code></td>
<td>x</td>
<td>x</td>
<td>Return destination IP address</td>
<td>x</td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_TOS</code></td>
<td>x</td>
<td>x</td>
<td>Type-of-service and precedence</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_TTL</code></td>
<td>x</td>
<td>x</td>
<td>TTL</td>
<td></td>
<td><code>int</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_MULTICAST_IF</code></td>
<td>x</td>
<td>x</td>
<td>Specify outgoing interface</td>
<td></td>
<td><code>in_addr{}</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_MULTICAST_TTL</code></td>
<td>x</td>
<td>x</td>
<td>Specify outgoing TTL</td>
<td></td>
<td><code>u_char</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_MULTICAST_LOOP</code></td>
<td>x</td>
<td>x</td>
<td>Specify loopback</td>
<td></td>
<td><code>u_char</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_{ADD,DROP}_MEMBERSHIP</code></td>
<td></td>
<td>x</td>
<td>Join or leave multicast group</td>
<td></td>
<td><code>ip_mreq{}</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_{BLOCK,UNBLOCK}_SOURCE</code></td>
<td></td>
<td>x</td>
<td>Block or unblock multicast source</td>
<td></td>
<td><code>ip_mreq_source{}</code></td>
</tr>
<tr>
<td></td>
<td><code>IP_{ADD,DROP}_SOURCE_MEMBERSHIP</code></td>
<td></td>
<td>x</td>
<td>Join or leave source-specific multicast</td>
<td></td>
<td><code>ip_mreq_source{}</code></td>
</tr>
</tbody>
</table>
<p><a href="../figure_7.1.png" title="Figure 7.1. Summary of socket and IP-layer socket options for getsockopt and setsockopt."><img alt="Figure 7.1. Summary of socket and IP-layer socket options for getsockopt and setsockopt." src="../figure_7.1.png" /></a></p>
<p>The following table lists transport-layer socket options.</p>
<p><a href="../figure_7.2.png" title="Figure 7.2. Summary of transport-layer socket options."><img alt="Figure 7.2. Summary of transport-layer socket options." src="../figure_7.2.png" /></a></p>
<p>There are two basic types of options:</p>
<ul>
<li><strong>Flags</strong>: binary options that enable or disable a certain feature (flags)</li>
<li><strong>Values</strong>: options that fetch and return specific values that we can either set or examine.</li>
</ul>
<p>The column labeled "Flag" specifies a flag option:</p>
<ul>
<li><code>getsockopt</code>: <code>*optval</code> is an integer. The value returned in <code>*optval</code> is zero if the option is disabled, or nonzero if the option is enabled.</li>
<li><code>setsockopt</code>: it requires a nonzero <code>*optval</code> to turn the option on, and a zero value to turn the option off.</li>
</ul>
<p>If the "Flag" column does not contain a block dot, then the option is used to pass a value of the specified datatype between the user process and the system.</p>
<h3 id="checking-if-an-option-is-supported-and-obtaining-the-default">Checking if an Option Is Supported and Obtaining the Default</h3>
<p><a href="https://github.com/shichao-an/unpv13e/blob/master/sockopt/checkopts.c">sockopt/checkopts.c</a></p>
<h3 id="socket-states">Socket States</h3>
<p>The following socket options are inherited by a connected TCP socket from the listening socket:</p>
<ul>
<li><code>SO_DEBUG</code></li>
<li><code>SO_DONTROUTE</code></li>
<li><code>SO_KEEPALIVE</code></li>
<li><code>SO_LINGER</code></li>
<li><code>SO_OOBINLINE</code></li>
<li><code>SO_RCVBUF</code></li>
<li><code>SO_RCVLOWAT</code></li>
<li><code>SO_SNDBUF</code></li>
<li><code>SO_SNDLOWAT</code></li>
<li><code>TCP_MAXSEG</code></li>
<li><code>TCP_NODELAY</code></li>
</ul>
<p>This is important with TCP because the connected socket is not returned to a server by <code>accept</code> until the three-way handshake is completed by the TCP layer. <u>To ensure that one of these socket options is set for the connected socket when the three-way handshake completes, we must set that option for the listening socket.</u></p>
<h3 id="generic-socket-options">Generic Socket Options</h3>
<p>Generic socket options are protocol-independent (they are handled by the protocol-independent code within the kernel, not by one particular protocol module such as IPv4), but some of the options apply to only certain types of sockets. For example, even though the <code>SO_BROADCAST</code> socket option is called "generic," it applies only to datagram sockets.</p>
<h3 id="ipv4-socket-options">IPv4 Socket Options</h3>
<h4 id="so_broadcast-socket-option"><code>SO_BROADCAST</code> Socket Option</h4>
<p>This option enables or disables the ability of the process to send broadcast messages. Broadcasting is supported for only datagram sockets and only on networks that support the concept of a broadcast message (e.g., Ethernet, token ring, etc.). You cannot broadcast on a point-to-point link or any connection-based transport protocol such as SCTP or TCP.</p>
<p>Since an application must set this socket option before sending a broadcast datagram, it prevents a process from sending a broadcast when the application was never designed to broadcast. For example, a UDP application might take the destination IP address as a command-line argument, but the application never intended for a user to type in a broadcast address. Rather than forcing the application to try to determine if a given address is a broadcast address or not, the test is in the kernel: If the destination address is a broadcast address and this socket option is not set, <code>EACCES</code> is returned.</p>
<h4 id="so_debug-socket-option"><code>SO_DEBUG</code> Socket Option</h4>
<p>This option is supported only by TCP. When enabled for a TCP socket, the kernel keeps track of detailed information about all the packets sent or received by TCP for the socket. These are kept in a <a href="https://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a> within the kernel that can be examined with the <code>trpt</code> program.</p>
<h4 id="so_dontroute-socket-option"><code>SO_DONTROUTE</code> Socket Option</h4>
<p>This option specifies that outgoing packets are to bypass the normal routing mechanisms of the underlying protocol. The destination must be on a directly-connected network, and messages are directed to the appropriate network interface according to the destination address [<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_10_16">Use of Options</a>]. For example, with IPv4, the packet is directed to the appropriate local interface, as specified by the network and subnet portions of the destination address. If the local interface cannot be determined from the destination address (e.g., the destination is not on the other end of a point-to-point link, or is not on a shared network), <code>ENETUNREACH</code> is returned.</p>
<p>The equivalent of this option can also be applied to individual datagrams using the <code>MSG_DONTROUTE</code> flag with the <code>send</code>, <code>sendto</code>, or <code>sendmsg</code> functions.</p>
<p>This option is often used by routing daemons (e.g., <code>routed</code> and <code>gated</code>) to bypass the routing table and force a packet to be sent out a particular interface.</p>
<h4 id="so_error-socket-option"><code>SO_ERROR</code> Socket Option</h4>
<p>This option is one that can be fetched but cannot be set.</p>
<p>When an error occurs on a socket, the protocol module in a Berkeley-derived kernel sets a variable named <code>so_error</code> for that socket to one of the standard Unix <code>E</code>xxx values. This is called the <em>pending error</em> for the socket. The process can be immediately notified of the error in one of two ways:</p>
<ol>
<li>If the process is blocked in a call to <code>select</code> on the socket (<a href="../ch6/#select-function">Section 6.3</a>), for either readability or writability, <code>select</code> returns with either or both conditions set.</li>
<li>If the process is using signal-driven I/O, the <code>SIGIO</code> signal is generated for either the process or the process group.</li>
</ol>
<p>The process can then obtain the value of <code>so_error</code> by fetching the <code>SO_ERROR</code> socket option. The integer value returned by <code>getsockopt</code> is the pending error for the socket. The value of <code>so_error</code> is then reset to 0 by the kernel.</p>
<ul>
<li>If <code>so_error</code> is nonzero when the process calls <code>read</code> and there is no data to return, <code>read</code> returns –1 with <code>errno</code> set to the value of <code>so_error</code>. The value of <code>so_error</code> is then reset to 0. If there is data queued for the socket, that data is returned by <code>read</code> instead of the error condition.</li>
<li>If <code>so_error</code> is nonzero when the process calls <code>write</code>, –1 is returned with <code>errno</code> set to the value of <code>so_error</code> and <code>so_error</code> is reset to 0.</li>
</ul>
<h4 id="so_keepalive-socket-option"><code>SO_KEEPALIVE</code> Socket Option</h4>
<p>When the keep-alive option is set for a TCP socket and no data has been exchanged across the socket in either direction for two hours, TCP automatically sends a <strong>keep-alive probe</strong> to the peer. This probe is a TCP segment to which the peer must respond. One of three scenarios results:</p>
<ol>
<li>The peer responds with the expected ACK. The application is not notified (since everything is okay). TCP will send another probe following another two hours of inactivity.</li>
<li>The peer responds with an RST, which tells the local TCP that the peer host has crashed and rebooted. The socket's pending error is set to <code>ECONNRESET</code> and the socket is closed.</li>
<li>There is no response from the peer to the keep-alive probe. Berkeley-derived TCPs send 8 additional probes, 75 seconds apart, trying to elicit a response. TCP will give up if there is no response within 11 minutes and 15 seconds after sending the first probe.</li>
</ol>
<h5 id="no-response-and-errors"><strong>No response and errors</strong> *</h5>
<ul>
<li>If there is no response at all to TCP's keep-alive probes, the socket's pending error is set to <code>ETIMEDOUT</code> and the socket is closed.</li>
<li>If the socket receives an ICMP error in response to one of the keep-alive probes, the corresponding error (<a href="../figure_a.15.png">Figures A.15</a> and <a href="../figure_a.16.png">Figure A.16</a>) is returned instead, and the socket is still closed.<ul>
<li>A common ICMP error in this scenario is "host unreachable", where the pending error is set to <code>EHOSTUNREACH</code>. This can occur because of either of the following:<ul>
<li>Network failure.</li>
<li><u>The remote host has crashed and the last-hop router has detected the crash.</u></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="changing-the-inactivity-time"><strong>Changing the inactivity time</strong> *</h5>
<p>A common question regarding this option is about modifying the timing parameters (usually to reduce the two-hour period of inactivity to some shorter value). Appendix E of TCPv1 discusses how to change these timing parameters for various kernels, but be aware that most kernels maintain these parameters on a per-kernel basis, not on a per-socket basis. For example, changing the inactivity period from 2 hours to 15 minutes will affect all sockets on the host that enables this option. However, such questions usually result from a misunderstanding of the purpose of this option, as discussed below.</p>
<h5 id="misunderstanding-of-the-purpose"><strong>Misunderstanding of the purpose</strong> *</h5>
<p><u>The purpose of this option is to detect if the peer <em>host</em> crashes or becomes unreachable</u> (e.g., dial-up modem connection drops, power fails, etc.). If the peer <em>process</em> crashes, its TCP will send a FIN across the connection, which we can easily detect with <code>select</code>, which was why we used <code>select</code> in <a href="../ch6/#str_cli-function-revisited">Section 6.4</a>. If there is no response to any of the keep-alive probes (scenario 3), we are not guaranteed that the peer host has crashed, and TCP may well terminate a valid connection. It could be that some intermediate router has crashed for 15 minutes, and that period of time just happens to completely overlap our host's 11-minute and 15-second keep-alive probe period. In fact, this function might more properly be called "make-dead" rather than "keep-alive" since it can terminate live connections.</p>
<h5 id="usages-of-the-so_keepalive-option"><strong>Usages of the <code>SO_KEEPALIVE</code> option</strong> *</h5>
<p>This option is normally used by servers, although clients can also use the option. Servers use the option because they spend most of their time blocked waiting for input across the TCP connection (waiting for a client request). The server process won't know if the client host's connection drops, is powered off, or crashes, and the server will continually wait for input (which never arrives). This is called a <strong>half-open connection</strong>. <u>The keep-alive option will detect these half-open connections and terminate them.</u></p>
<p>Some servers (e.g. FTP servers) provide an application timeout, often on the order of minutes. This is done by the application itself, normally around a call to <code>read</code>, reading the next client command. This timeout does not involve this socket option. This is often a better method of eliminating connections to missing clients, since the application has complete control if it implements the timeout itself.</p>
<h5 id="ways-to-detect-various-tcp-conditions"><strong>Ways to detect various TCP conditions</strong></h5>
<p>The following table (originally <a href="../figure_7.6.png">figure_7.6.png</a>) summarizes the various methods that we have to detect when something happens on the other end of a TCP connection. "Using <code>select</code> for readability" means calling <code>select</code> to test whether a socket is readable.</p>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Peer process crashes</th>
<th>Peer host crashes</th>
<th>Peer host is unreachable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Our TCP is actively sending data</td>
<td>Peer TCP sends a FIN, which we can detect immediately using <code>select</code> for readability. If TCP sends another segment, peer TCP responds with an RST. If the application attempts to write to the socket after TCP has received an RST, our socket implementation sends us <code>SIGPIPE</code>.</td>
<td>Our TCP will time out and our socket's pending error will be set to <code>ETIMEDOUT</code></td>
<td>Our TCP will time out and our socket's pending error will be set to <code>EHOSTUNREACH</code>.</td>
</tr>
<tr>
<td>Our TCP is actively receiving data</td>
<td>Peer TCP will send a FIN, which we will read as (possibly permature) EOF.</td>
<td>We will stop receiving data.</td>
<td>We will stop receiving data.</td>
</tr>
<tr>
<td>Connection is idle, keep-alive set</td>
<td>Peer TCP sends a FIN, which we can detect immediately using <code>select</code> for readability.</td>
<td>Nine keep-alive probes are sent after two hours of inactivity and then our socket's pending error is set to <code>ETIMEDOUT</code>.</td>
<td>Nine keep-alive probes are sent after two hours of inactivity and then our socket's pending error is set to <code>EHOSTUNREACH</code>.</td>
</tr>
<tr>
<td>Connection is idle, keep-alive not set</td>
<td>Peer TCP sends a FIN, which we can detect immediately using <code>select</code> for readability.</td>
<td>(Nothing)</td>
<td>(Nothing)</td>
</tr>
</tbody>
</table>
<h4 id="so_linger-socket-option"><code>SO_LINGER</code> Socket Option</h4>
<p>This option specifies how the <code>close</code> function operates for a connection-oriented protocol (for TCP, but not for UDP). By default, <code>close</code> returns immediately, but if there is any data still remaining in the socket send buffer, the system will try to deliver the data to the peer.</p>
<p>The <code>SO_LINGER</code> socket option can change this default. This option requires the following structure to be passed (as the <code>*optval</code> argument) between the user process and the kernel. It is defined by including <code>&lt;sys/socket.h&gt;</code>.</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">linger</span> <span class="p">{</span>
  <span class="kt">int</span>   <span class="n">l_onoff</span><span class="p">;</span>        <span class="cm">/* 0=off, nonzero=on */</span>
  <span class="kt">int</span>   <span class="n">l_linger</span><span class="p">;</span>       <span class="cm">/* linger time, POSIX specifies units as seconds */</span>
<span class="p">};</span>
</pre></div>


<p>Calling <code>setsockopt</code> leads to one of the following three scenarios, depending on the values of the two structure members:</p>
<ol>
<li>If <code>l_onoff</code> is 0, the option is turned off. The value of <code>l_linger</code> is ignored and the previously discussed TCP default applies: <code>close</code> returns immediately.</li>
<li>If <code>l_onoff</code> is nonzero and <code>l_linger</code> is zero, TCP aborts the connection when it is closed.<ul>
<li>In this case, TCP discards any data still remaining in the socket send buffer and sends an RST to the peer, not the normal four-packet connection termination sequence (<a href="../ch2/#tcp-connection-establishment-and-termination">Section 2.6</a>). See <a href="https://github.com/shichao-an/unpv13e/blob/master/nonblock/tcpcli03.c">example</a>.</li>
<li>This scenario avoids TCP's TIME_WAIT state, but leaves open the possibility of another incarnation of this connection being created within 2MSL seconds (<a href="#time_wait-state">Section 2.7</a>) and having old duplicate segments from the just-terminated connection being incorrectly delivered to the new incarnation.</li>
<li>Occasional USENET postings advocate the use of this feature just to avoid the TIME_WAIT state and to be able to restart a listening server even if connections are still in use with the server's well-known port. This should NOT be done and could lead to data corruption, as detailed in <a href="https://tools.ietf.org/html/rfc1337">RFC 1337</a>. Instead, the <code>SO_REUSEADDR</code> socket option should always be used in the server before the call to <code>bind</code>. <u>We should make use of the TIME_WAIT state to let old duplicate segments expire in the network rather than trying to avoid it.</u></li>
<li>There are certain circumstances which warrant using this feature to send an abortive close. One example is an <a href="https://en.wikipedia.org/wiki/RS-232">RS-232</a> terminal server, which might hang forever in CLOSE_WAIT trying to deliver data to a stuck terminal port, but would properly reset the stuck port if it got an RST to discard the pending data.</li>
</ul>
</li>
<li>If <code>l_onoff</code> is nonzero and <code>l_linger</code> is nonzero, then the kernel will linger when the socket is closed.<ul>
<li>In this scenario, if there is any data still remaining in the socket send buffer, the process is put to sleep until either:<ol>
<li>All the data is sent and acknowledged by the peer TCP, or</li>
<li>The linger time expires.</li>
</ol>
</li>
<li>If the socket has been set to nonblocking, it will not wait for the <code>close</code> to complete, even if the linger time is nonzero. When using this feature of the <code>SO_LINGER</code> option, it is important for the application to check the return value from <code>close</code>, because if the linger time expires before the remaining data is sent and acknowledged, <code>close</code> returns <code>EWOULDBLOCK</code> and any remaining data in the send buffer is discarded.</li>
</ul>
</li>
</ol>
<p>Given the above three scenarios, consider the situations when a <code>close</code> on a socket returns. Assume that the client writes data to the socket and then calls <code>close</code>.</p>
<h5 id="default-operation-of-close-it-returns-immediately"><strong>Default operation of <code>close</code>: it returns immediately</strong> *</h5>
<p><a href="../figure_7.7.png" title="Figure 7.7. Default operation of close: it returns immediately."><img alt="Figure 7.7. Default operation of close: it returns immediately." src="../figure_7.7.png" /></a></p>
<p>Assume that when the client's data arrives, the server is temporarily busy, so the data is added to the socket receive buffer by its TCP. Similarly, the next segment, the client's FIN, is also added to the socket receive buffer. But by default, the client's <code>close</code> returns immediately. In the scenario shown above, the client's <code>close</code> can return before the server reads the remaining data in its socket receive buffer. Therefore, it is possible for the server host to crash before the server application reads this remaining data, and the client application will never know.</p>
<h5 id="close-with-so_linger-socket-option-set-and-l_linger-a-positive-value"><strong><code>close</code> with <code>SO_LINGER</code> socket option set and <code>l_linger</code> a positive value</strong> *</h5>
<p>The client can set the <code>SO_LINGER</code> socket option, specifying some positive linger time. When this occurs, the client's <code>close</code> does not return until all the client's data and its FIN have been acknowledged by the server TCP, as shown in the figure below.</p>
<p><a href="../figure_7.8.png" title="Figure 7.8. close with SO_LINGER socket option set and l_linger a positive value."><img alt="Figure 7.8. close with SO_LINGER socket option set and l_linger a positive value." src="../figure_7.8.png" /></a></p>
<p>But this still has the same problem as in <a href="../figure_7.7.png">Figure 7.7</a>: The server host can crash before the server application reads its remaining data, and the client application will never know. Worse, the following figure shows what can happen when the <code>SO_LINGER</code> option is set to a value that is too low.</p>
<p><a href="../figure_7.9.png" title="Figure 7.9. close with SO_LINGER socket option set and l_linger a small positive value."><img alt="Figure 7.9. close with SO_LINGER socket option set and l_linger a small positive value." src="../figure_7.9.png" /></a></p>
<p>It is important to know that a successful return from <code>close</code>, with the <code>SO_LINGER</code> socket option set, only tells us that the data we sent (and our FIN) have been acknowledged by the peer TCP. This does not tell us whether the peer application has read the data. If we do not set the <code>SO_LINGER</code> socket option, we do not know whether the peer TCP has acknowledged the data.</p>
<h5 id="using-shutdown-to-know-that-peer-has-received-our-data"><strong>Using <code>shutdown</code> to know that peer has received our data</strong> *</h5>
<p>One way for the client to know that the server has read its data is to call <code>shutdown</code> (with a second argument of <code>SHUT_WR</code>) instead of <code>close</code> and wait for the peer to <code>close</code> its end of the connection. This scenario is shown in the figure below:</p>
<p><a href="../figure_7.10.png" title="Figure 7.10. Using shutdown to know that peer has received our data."><img alt="Figure 7.10. Using shutdown to know that peer has received our data." src="../figure_7.10.png" /></a></p>
<p>Depending on the function called (<code>close</code> or <code>shutdown</code>) and whether the <code>SO_LINGER</code> socket option is set, the return can occur at three different times:</p>
<ol>
<li><code>close</code> returns immediately, without waiting at all (the default; <a href="../figure_7.7.png">Figure 7.7</a>).</li>
<li><code>close</code> lingers until the ACK of our FIN is received (<a href="../figure_7.8.png">Figure 7.8</a> and <a href="../figure_7.9.png">Figure 7.9</a>).</li>
<li><code>shutdown</code> followed by a <code>read</code> waits until we receive the peer's FIN (<a href="../figure_7.10.png">Figure 7.10</a>).</li>
</ol>
<p>Another way to know that the peer application has read our data is to use an <em>application-level acknowledgment</em>, or <em>application ACK</em>. For example, in the following, the client sends its data to the server and then calls <code>read</code> for one byte of data:</p>
<div class="codehilite"><pre><span class="kt">char</span>  <span class="n">ack</span><span class="p">;</span>

<span class="n">Write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>       <span class="cm">/* data from client to server */</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>         <span class="cm">/* wait for application-level ACK */</span>
</pre></div>


<p>The server reads the data from the client and then sends back the one-byte application-level ACK:</p>
<div class="codehilite"><pre><span class="n">nbytes</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buff</span><span class="p">));</span> <span class="cm">/* data from client */</span>
         <span class="cm">/* server verifies it received correct</span>
<span class="cm">            amount of data from client */</span>
<span class="n">Write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>           <span class="cm">/* server&#39;s ACK back to client */</span>
</pre></div>


<p>It is guaranteed that when the <code>read</code> in the client returns, the server process has read the data we sent. (This assumes that either the server knows how much data the client is sending, or there is some application-defined end-of-record marker.) Here, the application-level ACK is a byte of 0, but the contents of this byte could be used to signal other conditions from the server to the client. The following figure shows the possible packet exchange.</p>
<p><a href="../figure_7.11.png" title="Figure 7.11. Application ACK."><img alt="Figure 7.11. Application ACK." src="../figure_7.11.png" /></a></p>
<p>The following table summarizes the two possible calls to <code>shutdown</code> and the three possible calls to <code>close</code> (with <code>SO_LINGER</code> scenarios), and the effect on a TCP socket.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shutdown</code>, <code>SHUT_RD</code></td>
<td>No more receives can be issued on the socket; process can still send on socket; socket receive buffer discarded; any further data received is discarded by TCP; no effect on socket send buffer.</td>
</tr>
<tr>
<td><code>shutdown</code>, <code>SHUT_WR</code></td>
<td>No more sends can be issued on socket; process can still receive on socket; contents of socket send buffer sent to other end, followed by normal TCP connection termination (FIN); no effect on socket receive buffer.</td>
</tr>
<tr>
<td><code>close</code>, <code>l_onoff = 0</code> (default)</td>
<td>No more receives or sends can be issued on socket; contents of socket send buffer sent to other end. If descriptor reference count becomes 0: normal TCP connection termination (FIN) sent following data in send buffer and socket receive buffer discarded.</td>
</tr>
<tr>
<td><code>close</code>, <code>l_onoff = 1</code>, <code>l_linger = 0</code></td>
<td>No more receives or sends can be issued on socket. If descriptor reference count becomes 0: RST sent to other end; connection state set to CLOSED (no TIME_WAIT state); socket send buffer and socket receive buffer discarded.</td>
</tr>
<tr>
<td><code>close</code>, <code>l_onoff = 1</code>, <code>l_linger != 0</code></td>
<td>No more receives or sends can be issued on socket; contents of socket send buffer sent to other end. If descriptor reference count becomes 0: normal TCP connection termination (FIN) sent following data in send buffer; socket receive buffer discarded; and if linger time expires before connection CLOSED, <code>close</code> returns <code>EWOULDBLOCK</code>.</td>
</tr>
</tbody>
</table>
<h3 id="icmpv6-socket-option">ICMPv6 Socket Option</h3>
<h3 id="ipv6-socket-options">IPv6 Socket Options</h3>
<h3 id="tcp-socket-options">TCP Socket Options</h3>
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<p>Section 7.5 on <code>SO_KEEPALIVE</code> Socket Option.</p>
<blockquote>
<p>Appendix E of TCPv1 discusses how to change these timing parameters for various kernels, ...</p>
</blockquote>
<p>I did not find Appendix E (actually no appendix at all) in TCPv1 (3rd Edition).</p>
<p>Section 7.5 on <code>SO_LINGER</code></p>
<blockquote>
<p>One example is an RS-232 terminal server, which might hang forever in CLOSE_WAIT trying to deliver data to a stuck terminal port, but would properly reset the stuck port if it got an RST to discard the pending data.</p>
</blockquote>
<p>Not fully understood.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>